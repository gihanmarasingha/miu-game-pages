{"name": "MIU Game", "version": "1.1.2", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "MIU Game-1.1.2-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}, {"type": "lean", "content": "2", "hidden": true}]}, "worlds": [{"name": "3", "levels": [{"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "4", "hidden": true}, {"type": "text", "content": "5"}, {"type": "lean", "content": "6", "hidden": true}, {"type": "text", "content": "7"}, {"type": "axiom", "content": "8", "name": "der_MI : derivable \"MI\"", "sideBar": true}, {"type": "lean", "content": "9", "hidden": true}, {"type": "axiom", "content": "10", "name": "rule1 x : derivable xI \u2192 derivable xIU", "sideBar": true}, {"type": "lean", "content": "11", "hidden": true}, {"type": "axiom", "content": "12", "name": "rule2 x : derivable Mx \u2192 derivable Mxx", "sideBar": true}, {"type": "lean", "content": "13", "hidden": true}, {"type": "axiom", "content": "14", "name": "rule3 x : derivable xIIIy \u2192 derivable xUy", "sideBar": true}, {"type": "lean", "content": "15", "hidden": true}, {"type": "axiom", "content": "16", "name": "rule4 x : derivable xUUy \u2192 derivable xy", "sideBar": true}, {"type": "lean", "content": "17", "hidden": true}, {"type": "text", "content": "18"}, {"type": "tactic", "content": "19", "name": "from", "sideBar": true}, {"type": "theorem", "text": "20", "lean": "example : derivable \"MI\" :=\n", "sideBar": false, "firstProofLineNumber": 68, "lastProofLineNumber": 69, "textBefore": "import miu.basic -- hide\n\n/-\n## Level 1: The base case and the from tactic\n-/\n\nopen letter -- hide\n\n/-\nThe starting point of the MIU system is the assertion that `\"MI\"` is derivable. This\nfact is called `der_MI`.\n\nA description of `der_MI`, and the other rules of the system, can be seen in the _Theorem statements_ drop-down\nmenu at the left of the screen.\nAs you progress through this game, new results will be added to the menu.\n-/\n\n/- Axiom : der_MI : derivable \"MI\"\n-/\nlemma der_MI : derivable [M, I] := derivable.derivable_MI -- hide\n\n/- Axiom : rule1 x : derivable xI \u2192 derivable xIU\n-/\nlemma rule1 (x) (h : derivable (x ++ [I])) : derivable (x ++ [I, U]) := derivable.r1 h -- hide\n\n/- Axiom : rule2 x : derivable Mx \u2192 derivable Mxx\n-/\nlemma rule2 (x) (h : derivable (M :: x)) : derivable (M :: x ++ x) := derivable.r2 h -- hide\n\n/- Axiom : rule3 x : derivable xIIIy \u2192 derivable xUy\n-/\nlemma rule3 (x) {y} (h : derivable (x ++ \"III\" ++ y)) : derivable (x ++ (U :: y)) := derivable.r3 h -- hide\n\n/- Axiom : rule4 x : derivable xUUy \u2192 derivable xy\n-/\nlemma rule4 (x) {y} (h : derivable (x ++ \"UU\" ++ y)) : derivable (x ++ y) := derivable.r4 h -- hide\n\n/-\nBelow, we're going to use this fact, trivially, to prove `\"MI\"` is derivable.\n\nDelete the word `sorry` below. The top pane on the right will display the current goal,\n`derivable \"MI\"`. You'll see an error message in the bottom-right pane. Don't panic; this just\nmeans the proof is incomplete.\n\nFinish the proof by typing `from der_MI,` in place of the `sorry`. Don't forget the comma at the end of the\nsentence.\n\nThe error message will disappear and the top pane will display 'Proof complete!'. If 'no goals' is\ndisplayed instead, press the enter key to add a blank line at the end of the proof.\n\nCongratulations, you've finished your first proof! Move on to the next level by using the button\nin the top right.\n-/\n\n\n/- Tactic : from\n## Summary\n`from` is a finishing move used to close a goal.\n## Details\nIf `h` is a proof of the target, `from h,` will close the goal.\n-/\n\n/- Theorem : no-side-bar\nThe string `\"MI\"` is derivable.\n-/\nexample : derivable \"MI\" :=\nbegin\n", "proof": "\n  from der_MI", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Tactics\n\n`from` is a _tactic_. The `from` tactic is a finishing move used to close a goal by providing a \nproof of the target. \nNotes on tactics will be added to the _Tactics_ drop-down menu on the left.\n-/\n", "height": 2, "editorText": "sorry", "lineOffset": 67, "name": "", "statement": "derivable \"MI\""}, {"type": "text", "content": "21"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "22", "hidden": true}, {"type": "lean", "content": "23", "hidden": true}, {"type": "text", "content": "24"}, {"type": "text", "content": "25"}, {"type": "text", "content": "26"}, {"type": "tactic", "content": "27", "name": "apply", "sideBar": true}, {"type": "theorem", "text": "28", "lean": "theorem der_MIU : derivable \"MIU\" :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 44, "textBefore": "import game.rule_practice.level1 -- hide\n\nopen letter -- hide\n\n/-\n## Level 2: Rule 1 and the apply tactic\n-/\n\n/-\nThe first rule of the MIU system states \nthat if xI is derivable, then xIU is derivable, for any string x.\n-/\n\n/-\nBelow, replace `sorry` with `apply rule1 \"M\",` (don't forget the comma).\nThis applies rule 1 with `\"M\"` in place of x.\n\nThe inital target of proving `\"MIU\"` is replaced with the target of proving `\"MI\"` is derivable\n(this is displayed as the goal `derivable (\"M\" ++ [I])`).\n\nBut `der_MI` is a proof of this fact! To use this result, type\n`from der_MI,` on the next line.\n-/\n\n\n/- Tactic : apply\n## Summary\n`apply` transforms the target using a supplied theorem.\n## Details\nSuppose the theorem `h` states 'if `p`, then `q`'. If the target is to prove `q`,\nthen `apply h` changes the target to `p`.\n\nThis tactic is used for _backward reasoning_.\n-/\n\n/- Theorem : der_MIU\n`\"MIU\"` is derivable\n-/\ntheorem der_MIU : derivable \"MIU\" :=\nbegin\n", "proof": "  apply rule1 \"M\",\n  from der_MI,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\n## Backward reasoning\n\nWhen we used the `apply` tactic, we employed _backward reasoning_. Initially, the target was to\nprove `\"MIU\"` is derivable. Rule 1 tells us that if xI is derivable, then so is xIU. Taking\n`\"M\"` for x makes xIU match the target. Thus, applying rule 1, it suffices to prove the intermediate goal that `\"MI\"`\nis derivable.\n-/", "height": 4, "editorText": "sorry", "lineOffset": 40, "name": "der_MIU", "statement": "derivable \"MIU\""}, {"type": "text", "content": "29"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "text", "content": "32"}, {"type": "text", "content": "33"}, {"type": "text", "content": "34"}, {"type": "text", "content": "35"}, {"type": "tactic", "content": "36", "name": "have", "sideBar": true}, {"type": "theorem", "text": "37", "lean": "example : derivable \"MIU\" :=\n", "sideBar": false, "firstProofLineNumber": 59, "lastProofLineNumber": 62, "textBefore": "import game.rule_practice.level2 -- hide\n\nopen letter -- hide\n\n/-\n## Level 3: Introducing hypotheses with the have tactic\n-/\n\n/-\nIn the previous level, we started with the target of showing `\"MIU\"` is derivable and\nwe used the `apply` tactic with rule 1 to reason _backward_, replacing the target of deriving\n`\"MIU\"` with the target of deriving `\"MI\"`\n-/\n\n/-\nIn this level, we use the `have` tactic to reason _forward_.\n-/\n\n\n/-\nType\n```\nhave h : derivable \"MI\", from der_MI,\n```\nas the first line of the proof below. You'll see that the top-right pane changes to show\n```\nh : derivable \"MI\"\n\u22a2 derivable \"MIU\"\n```\nThe target hasn't changed, but now we have `h`, a proof of `derivable \"MI\"`.\n\nRecall rule 1 states that if xI is derivable, then so is xIU.\nFor the next line, type\n```\nfrom rule1 \"M\" h,\n```\nThis closes the goal using rule 1 with `\"M\"` in place of x and `h` as the proof that `\"MI\"` (i.e. xI)\nis derivable.\n-/\n\n\n\n\n/- Tactic : have\n## Summary\n`have` introduces a new hypothesis into the context.\n## Details\nIf `t` is a proof of proposition `\u03b1`, then `have h : \u03b1, from t` introduces `h`, a proof of\n`\u03b1` into the context.\n## Example\n\n-/\n\n/- Theorem : no-side-bar\n`\"MIU\"` is derivable\n-/\nexample : derivable \"MIU\" :=\nbegin\n", "proof": "  have h : derivable \"MI\", from der_MI,\n  from rule1 \"M\" h,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## A quicker forward proof\n\nThere's a one-line forward proof. Here, the proof of `h` is `der_MI`. Thus, we can replace the\nsecond line with\n```\nfrom rule1 \"M\" der_MI,\n```\nand then delete the `have` line.\n-/\n", "height": 4, "editorText": "sorry", "lineOffset": 58, "name": "", "statement": "derivable \"MIU\""}, {"type": "text", "content": "38"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "text", "content": "41"}, {"type": "text", "content": "42"}, {"type": "text", "content": "43"}, {"type": "text", "content": "44"}, {"type": "theorem", "text": "45", "lean": "theorem der_MII : derivable \"MII\" :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 34, "textBefore": "import game.rule_practice.level3 -- hide\n\nopen letter -- hide\n\n/-\n## Level 4: Rule 2\n-/\n\n/-\nRule 2 states derivable Mx \u2192 derivable Mxx. \n-/\n\n\n/-\nYou can solve the following problem in (at least) one of two ways.\n\n1. Type `apply rule2 x,` with an approriate choice of `x`. This leaves a goal that you can\nclose in one line, using a previous result.\n\n2. Using `from rule2 x t,` with appropriate `x` and `t` gives a one-line proof.\n-/\n/-\n\n-/\n\n/- Theorem : der_MII\n`\"MII\"` is derivable.\n-/\ntheorem der_MII : derivable \"MII\" :=\nbegin\n", "proof": "  apply rule2 \"I\",\n  from der_MI,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 30, "name": "der_MII", "statement": "derivable \"MII\""}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "46", "hidden": true}, {"type": "lean", "content": "47", "hidden": true}, {"type": "text", "content": "48"}, {"type": "text", "content": "49"}, {"type": "text", "content": "50"}, {"type": "hint", "content": "51", "title": "52"}, {"type": "hint", "content": "53", "title": "54"}, {"type": "theorem", "text": "55", "lean": "example : derivable \"MIUIUIUIU\" :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 49, "textBefore": "import game.rule_practice.level4 -- hide\n\nopen letter -- hide\n\n/-\n## Level 5: Rule 2 practice\n-/\n\n\n/-\nProve \"MIUIUIUIU\" is derivable. You'll need more than one\napplication of rule 2. Don't forget you can use any of the results\nlisted in the _Theorem statements_ drop-down menu.\n-/\n\n/-\nYou can prove this either (1) backward, using `apply` in your first line or (2) forward, using\n`have` in your first line. Try both approaches.\n\n**Note** in a forward proof, you can use an underscore (`_`) in place of the rule 2 variable x. Lean\nwill infer the correct value.\n-/\n\n/- Hint : Hint for backward proof\nThe first line of a backward proof should take the form\n```\napply rule2 x,\n```\nfor some string `x` such that the target takes the form Mxx\n-/\n\n/- Hint : Hint for forward proof\nUse the following as the first line of a forward proof.\n```\nhave h : derivable \"MIUIU\", from rule2 _ t\n```\nt is the name of a theorem that Mx is derivable, where the target is Mxx.\n-/\n\n/- Theorem : no-side-bar\n`\"MIUIUIUIU\"` is derivable\n-/\nexample : derivable \"MIUIUIUIU\" :=\nbegin\n", "proof": "  apply rule2 \"IUIU\",\n  apply rule2 \"IU\",\n  from der_MIU,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n-- begin hide\nexample : derivable \"MIUIUIUIU\" :=\nbegin\n  have h : derivable \"MIUIU\", from rule2 _ der_MIU,\n  from rule2 _ h,\nend\n-- end hide", "height": 5, "editorText": "sorry", "lineOffset": 44, "name": "", "statement": "derivable \"MIUIUIUIU\""}, {"type": "lean", "content": "56", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "57", "hidden": true}, {"type": "lean", "content": "58", "hidden": true}, {"type": "text", "content": "59"}, {"type": "text", "content": "60"}, {"type": "text", "content": "61"}, {"type": "theorem", "text": "62", "lean": "example : derivable \"MIIUIIUIIUIIU\" :=\n", "sideBar": false, "firstProofLineNumber": 25, "lastProofLineNumber": 31, "textBefore": "import game.rule_practice.level5 -- hide\n\nopen letter -- hide\n\n/-\n## Level 6: Further practice with rules 1 and 2\n-/\n\n\n/-\nNow for some fun. Let's prove \"MIIUIIUIIUIIU\" is derivable. You'll need several applications\nof rules 1 and 2.\n-/\n\n/-\nTry this both forward and backward. For your forward proof, call the hypotheses `h1`, `h2`, etc.\nYou can use underscores to replace variables in forward applications of rule 2, though not rule 1.\n-/\n\n/- Theorem : no-side-bar\n`\"MIIUIIUIIUIIU\"` is derivable\n-/\nexample : derivable \"MIIUIIUIIUIIU\" :=\nbegin\n", "proof": "  apply rule2 \"IIUIIU\",\n  apply rule2 \"IIU\",\n  apply rule1 \"MI\",\n  from der_MII,\n/-   have h1 : derivable \"MIIU\", from rule1 \"MI\" der_MII,\n  have h2 : derivable \"MIIUIIU\", from rule2 _ h1,\n  from rule2 _ h2, -/", "proof_hint": "sorry", "textAfter": "\nend\n\n-- begin hide\nexample : derivable \"MIIUIIUIIUIIU\" :=\nbegin\n  have h1 : derivable \"MIIU\", from rule1 \"MI\" der_MII,\n  have h2 : derivable \"MIIUIIU\", from rule2 _ h1,\n  from rule2 _ h2,\nend\n-- end hide\n", "height": 7, "editorText": "sorry", "lineOffset": 24, "name": "", "statement": "derivable \"MIIUIIUIIUIIU\""}, {"type": "lean", "content": "63", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "text", "content": "66"}, {"type": "text", "content": "67"}, {"type": "text", "content": "68"}, {"type": "lean", "content": "69", "hidden": false}, {"type": "text", "content": "70"}, {"type": "text", "content": "71"}, {"type": "theorem", "text": "72", "lean": "example (h : derivable \"MMIIIIIM\"): derivable \"MMIUIM\" :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 46, "textBefore": "import game.rule_practice.level6 -- hide\n\nopen letter -- hide\n\n/-\n## Level 7 : Rule 3\n-/\n\n\n/-\nRules 1 and 2 are _lengthening_ rules. They show how to derive a longer string given the\nderivation of a shorter string.\n\nRules 3 and 4 are shortening rules.\n\nIn particular, rule 3 states xIIIy \u2192 xUy \n-/\n\n/-\nIn the example below, we show `\"UMUIM\"` is derivable on the assumption `h`, that\n`\"UMIIIIM\"` is derivable. We specify `x` as `\"UM\"` in using rule 3. You don't need to specify the\nstring `y`. Lean automatically infers this value.\n-/\n\nexample (h : derivable \"UMIIIIM\") : derivable \"UMUIM\" :=\nbegin\n  from rule3 \"UM\" h,\nend\n\n/-\n**Note** this example does not show `\"UMUIM\"` is derivable! Why not?\n-/\n\n\n/-\nSolve the next problem by adapting the proof of the example above.\n-/\n\n/- Theorem : no-side-bar\nIf `\"MMIIIIIM\"` is derivable, then so is `\"MMIUIM\"`.\n-/\nexample (h : derivable \"MMIIIIIM\"): derivable \"MMIUIM\" :=\nbegin\n", "proof": "  from rule3 \"MMI\" h,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 43, "name": "", "statement": "(h : derivable \"MMIIIIIM\"): derivable \"MMIUIM\""}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "text", "content": "76"}, {"type": "theorem", "text": "77", "lean": "example : derivable \"MUIU\" :=\n", "sideBar": false, "firstProofLineNumber": 19, "lastProofLineNumber": 23, "textBefore": "import game.rule_practice.level7 -- hide\n\nopen letter -- hide\n\n/-\n## Level 8 : Rules 1, 2, and 3 practice\n-/\n\n/-\nGive a backward proof and a forward proof for the problem below.\n-/\n\n\n/- Theorem : no-side-bar\n`\"MUIU\"` is derivable.\n-/\nexample : derivable \"MUIU\" :=\nbegin\n", "proof": "  have h1 : derivable \"MIIII\", from rule2 _ der_MII,\n  have h2 : derivable \"MIIIIU\", from rule1 \"MIII\" h1,\n  from rule3 \"M\" h2,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n-- begin hide\nexample : derivable \"MUIU\" :=\nbegin\n  apply rule3 \"M\",\n  apply rule1,\n  apply rule2 \"II\",\n  apply der_MII,\nend\n-- end hide", "height": 5, "editorText": "sorry", "lineOffset": 18, "name": "", "statement": "derivable \"MUIU\""}, {"type": "lean", "content": "78", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "79", "hidden": true}, {"type": "lean", "content": "80", "hidden": true}, {"type": "text", "content": "81"}, {"type": "text", "content": "82"}, {"type": "lean", "content": "83", "hidden": false}, {"type": "text", "content": "84"}, {"type": "theorem", "text": "85", "lean": "example (h : derivable \"UMUUUI\"): derivable \"UMUI\" :=\n", "sideBar": false, "firstProofLineNumber": 29, "lastProofLineNumber": 31, "textBefore": "import game.rule_practice.level8 -- hide\n\nopen letter -- hide\n\n/-\n## Level 9 : Rule 4\n-/\n\n/-\nRule 4 states xUUy \u2192 xy.\n\nAgain, we only need specify the `x` value. Lean automatically infers `y`.\n-/\n\nexample (h : derivable \"IMUUI\") : derivable \"IMI\" :=\nbegin\n  from rule4 \"IM\" h,\nend\n\n/-\nAdapt the example to prove the result below. Then give a proof with a different value for `x`.\n-/\n\n/- Theorem : no-side-bar\nIf `\"UMUUUI\"` is derivable, then so is `\"UMUI\"`.\n-/\nexample (h : derivable \"UMUUUI\"): derivable \"UMUI\" :=\nbegin\n", "proof": "  from rule4 \"UMU\" h,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 28, "name": "", "statement": "(h : derivable \"UMUUUI\"): derivable \"UMUI\""}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "text", "content": "88"}, {"type": "text", "content": "89"}, {"type": "theorem", "text": "90", "lean": "example : derivable \"MIIUII\" :=\n", "sideBar": false, "firstProofLineNumber": 24, "lastProofLineNumber": 46, "textBefore": "import game.rule_practice.level9 -- hide\n\nopen letter -- hide\n\n/-\n## Level 10 : All rules practice\n-/\n\n/-\nWe've seen all rules now.\n\nThe next derivation is more challenging than the examples we've seen so far.\n\nThis is the last level of the first world. Before you move on to the next world, ask yourself, if\n`\"MU\"` can be derived.\n-/\n\n\n/- Theorem : no-side-bar\n`\"MIIUII\"` is derivable\n-/\nexample : derivable \"MIIUII\" :=\nbegin\n", "proof": "  apply rule3 \"MII\",\n  apply rule4 \"MIIIIIII\",\n  apply rule3 \"MIIIIIII\",\n  apply rule1 \"MIIIIIIIII\",\n  apply rule4 \"MIIIIIIIIII\",\n  apply rule3 \"MIIIIIIIIII\",\n  apply rule3 \"MIIIIIIIIIIIII\",\n  apply rule2 \"IIIIIIII\",\n  apply rule2 \"IIII\",\n  apply rule2 \"II\",\n  from der_MII,\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 23, "editorText": "sorry", "lineOffset": 23, "name": "", "statement": "derivable \"MIIUII\""}]}]}, {"name": "91", "levels": [{"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "92", "hidden": true}, {"type": "lean", "content": "93", "hidden": true}, {"type": "text", "content": "94"}, {"type": "text", "content": "95"}, {"type": "text", "content": "96"}, {"type": "tactic", "content": "97", "name": "use", "sideBar": true}, {"type": "text", "content": "98"}, {"type": "axiom", "content": "99", "name": "cons (::)", "sideBar": true}, {"type": "example", "text": "101", "lean": "example : \u2203 a, derivable (a :: \"II\") :=\n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 56, "textBefore": "import game.rule_practice.level10 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 1 : The existential quatifier\n-/\n\n/-\nWe've seen proofs that particular strings can be derived. In this world, we'll see how to \nprove that strings can be derived that satisfy certain properties.\n-/\n\n/-\nThe example below claims there exists a letter a such that aII is derivable. The symbol \u2203 stands\nfor 'there exists'.\n\nThe notation `a :: \"II\"` means a letter represented by variable `a` followed by the string `\"II\"`.\n-/\n\n/- Tactic : use\n## Summary\n`use` is the first step in proving the existence of a term that satisfies a property.\n\n## Detail\nSuppose the target is to prove `\u2203 a, P(a)`, where `P` is some property. Suppose `m` is a term.\nThen\n```\nuse m\n```\nchanges the target to one of proving `P(m)`.\n\n## Variations\nIf the target is to prove `\u2203 a b, P a b` and `m`, `m` are terms, then\n```\nuse [m, n]\n```\nreplaces the target with one of proving `P m n`.\n-/\n\n/-\nThe tactic `use M` fixes x to be `M` and changes the target to one of showing that\n`M :: \"II\"` is derivable. This is precisely the conclusion of `der_MII`.\n-/\n\n/- Axiom : cons (::)\na :: y is the letter a followed by the string y.\n-/\n\n/- Example : no-side-bar\nThere exists a letter a such that aII is derivable.\n-/\nexample : \u2203 a, derivable (a :: \"II\") :=\nbegin\n", "proof": "  use M,\n  from der_MII,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Theorem : no-side-bar\nThere exists a letter a such that aIU is derivable.\n-/\nexample : \u2203 a, derivable (a :: \"IU\") :=\nbegin\n  use M,\n  from der_MIU,\n\n\nend\n", "height": 2, "editorText": "100", "lineOffset": 54, "statement": "\u2203 a, derivable (a :: \"II\")"}, {"type": "theorem", "text": "102", "lean": "example : \u2203 a, derivable (a :: \"IU\") :=\n", "sideBar": false, "firstProofLineNumber": 64, "lastProofLineNumber": 67, "textBefore": "import game.rule_practice.level10 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 1 : The existential quatifier\n-/\n\n/-\nWe've seen proofs that particular strings can be derived. In this world, we'll see how to \nprove that strings can be derived that satisfy certain properties.\n-/\n\n/-\nThe example below claims there exists a letter a such that aII is derivable. The symbol \u2203 stands\nfor 'there exists'.\n\nThe notation `a :: \"II\"` means a letter represented by variable `a` followed by the string `\"II\"`.\n-/\n\n/- Tactic : use\n## Summary\n`use` is the first step in proving the existence of a term that satisfies a property.\n\n## Detail\nSuppose the target is to prove `\u2203 a, P(a)`, where `P` is some property. Suppose `m` is a term.\nThen\n```\nuse m\n```\nchanges the target to one of proving `P(m)`.\n\n## Variations\nIf the target is to prove `\u2203 a b, P a b` and `m`, `m` are terms, then\n```\nuse [m, n]\n```\nreplaces the target with one of proving `P m n`.\n-/\n\n/-\nThe tactic `use M` fixes x to be `M` and changes the target to one of showing that\n`M :: \"II\"` is derivable. This is precisely the conclusion of `der_MII`.\n-/\n\n/- Axiom : cons (::)\na :: y is the letter a followed by the string y.\n-/\n\n/- Example : no-side-bar\nThere exists a letter a such that aII is derivable.\n-/\nexample : \u2203 a, derivable (a :: \"II\") :=\nbegin\n  use M,\n  from der_MII,\nend\n\n/- Theorem : no-side-bar\nThere exists a letter a such that aIU is derivable.\n-/\nexample : \u2203 a, derivable (a :: \"IU\") :=\nbegin\n", "proof": "  use M,\n  from der_MIU,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 63, "name": "", "statement": "\u2203 a, derivable (a :: \"IU\")"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "103", "hidden": true}, {"type": "lean", "content": "104", "hidden": true}, {"type": "text", "content": "105"}, {"type": "text", "content": "106"}, {"type": "axiom", "content": "107", "name": "append (++)", "sideBar": true}, {"type": "example", "text": "109", "lean": "example : \u2203 a y, derivable (a :: y ++ y) :=\n", "sideBar": false, "firstProofLineNumber": 27, "lastProofLineNumber": 28, "textBefore": "import game.existence.level1 -- hide\n\nopen letter -- hide\n\n/-\n## Level 2 : Letters and strings\n-/\n\n/-\nThe notation `x ++ y` means 'the string `x` followed by the string `y`'. Thus,\n`\"ho\" ++ \"use\"` is `\"house\"`.\n\nWe'll prove that there is a letter `a` and a string `y` such that `a :: y ++ y` is derivable by\ntaking `M` for `a` and `\"I\"` for `y`.\nNote that string constants are surrounded by double quotes.\n-/\n\n/- Axiom : append (++)\nx ++ y is the string x followed by the string y.\n-/\n\n/- Example : no-side-bar\nThere exists a letter a and a string y such that ayy is derivable.\n-/\nexample : \u2203 a y, derivable (a :: y ++ y) :=\nbegin\n", "proof": "  use [M, \"I\"],  \n  from der_MII,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nGive a solution to the following problem. Give another solution.\nHow many solutions are there?\n-/\n\n/- Theorem : no-side-bar\nThere exists a letter a and strings y, z such that ayzyz is derivable.\n-/\nexample : \u2203 a y z, derivable (a :: (y ++ z) ++ (y ++ z)) :=\nbegin\n  use [M, \"I\", \"U\"],\n  apply rule2 \"IU\",\n  from der_MIU,\n\n\nend\n", "height": 2, "editorText": "108", "lineOffset": 26, "statement": "\u2203 a y, derivable (a :: y ++ y)"}, {"type": "text", "content": "110"}, {"type": "theorem", "text": "111", "lean": "example : \u2203 a y z, derivable (a :: (y ++ z) ++ (y ++ z)) :=\n", "sideBar": false, "firstProofLineNumber": 41, "lastProofLineNumber": 45, "textBefore": "import game.existence.level1 -- hide\n\nopen letter -- hide\n\n/-\n## Level 2 : Letters and strings\n-/\n\n/-\nThe notation `x ++ y` means 'the string `x` followed by the string `y`'. Thus,\n`\"ho\" ++ \"use\"` is `\"house\"`.\n\nWe'll prove that there is a letter `a` and a string `y` such that `a :: y ++ y` is derivable by\ntaking `M` for `a` and `\"I\"` for `y`.\nNote that string constants are surrounded by double quotes.\n-/\n\n/- Axiom : append (++)\nx ++ y is the string x followed by the string y.\n-/\n\n/- Example : no-side-bar\nThere exists a letter a and a string y such that ayy is derivable.\n-/\nexample : \u2203 a y, derivable (a :: y ++ y) :=\nbegin\n  use [M, \"I\"],  \n  from der_MII,\nend\n\n/-\nGive a solution to the following problem. Give another solution.\nHow many solutions are there?\n-/\n\n/- Theorem : no-side-bar\nThere exists a letter a and strings y, z such that ayzyz is derivable.\n-/\nexample : \u2203 a y z, derivable (a :: (y ++ z) ++ (y ++ z)) :=\nbegin\n", "proof": "  use [M, \"I\", \"U\"],\n  apply rule2 \"IU\",\n  from der_MIU,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 40, "name": "", "statement": "\u2203 a y z, derivable (a :: (y ++ z) ++ (y ++ z))"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "text", "content": "114"}, {"type": "text", "content": "115"}, {"type": "text", "content": "116"}, {"type": "example", "text": "118", "lean": "example (h : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))) :\n\u2203 (s t : miustr), derivable (M :: s ++ \"M\" ++ (t ++ \"M\")) :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 36, "textBefore": "import game.existence.level2 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 3 : Doing something with your existence\n-/\n\n/-\nThe `use` tactic enables us to _prove_ existence. What if we're given the existence of some\nquantity. How do we use that information?\n-/\n\n/-\nBelow `cases h with x hx` decomposes the `\u2203` statement\n```\nh : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))\n```\nIt replaces `h` with:\n1. a new string variable `z` and\n2. a new hypothesis `hz : derivable (M :: (z ++ \"M\"))`.\n\nWe then take `z` in place of `s` and `t` to prove the target.\n-/\n\n/- Example : no-side-bar\nGiven that there exists a string `x` such that `M :: (x ++ \"M\")` is derivable,\nthere exist strings `s` and `t` such that `M :: s ++ \"M\" ++ (t ++ \"M\")` is derivable.\n-/\nexample (h : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))) :\n\u2203 (s t : miustr), derivable (M :: s ++ \"M\" ++ (t ++ \"M\")) :=\nbegin\n", "proof": "  cases h with z hz,\n  use [z, z],\n  apply rule2 (z ++ \"M\"),\n  from hz,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : cases\n## Summary\n`cases` is used to decompose a hypothesis.\n\n## Detail\nIf `h : p \u2228 q`, then `cases h with h1 h2` creates two new goals: (1) to prove the target under\nthe assumption `h1 : p` and (2) to prove the target under the assumption `h2 : q`.\n\nIf `h : \u2203 x, p x`, then `cases h with z hz` creates two new items in the context: (1) a\nvariable `z` and (2) the hypothesis `hz : p z`.\n-/\n\n\n/- Theorem : no-side-bar\nGiven there exists `x` such that `M :: (x ++ [I])` is derivable, we have that\nthere exists `y` such that `M :: (y ++ [I, U])` is derivable.\n-/\nexample (h : \u2203 x, derivable (M :: (x ++ [I]))) :\n\u2203 y, derivable (M :: (y ++ [I, U])) :=\nbegin\n  cases h with z hz,\n  use z,\n  apply rule1 (M :: z),\n  from hz,\n\n\n\nend", "height": 4, "editorText": "117", "lineOffset": 32, "statement": "(h : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))) :\n\u2203 (s t : miustr), derivable (M :: s ++ \"M\" ++ (t ++ \"M\"))"}, {"type": "tactic", "content": "119", "name": "cases", "sideBar": true}, {"type": "theorem", "text": "120", "lean": "example (h : \u2203 x, derivable (M :: (x ++ [I]))) :\n\u2203 y, derivable (M :: (y ++ [I, U])) :=\n", "sideBar": false, "firstProofLineNumber": 60, "lastProofLineNumber": 66, "textBefore": "import game.existence.level2 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 3 : Doing something with your existence\n-/\n\n/-\nThe `use` tactic enables us to _prove_ existence. What if we're given the existence of some\nquantity. How do we use that information?\n-/\n\n/-\nBelow `cases h with x hx` decomposes the `\u2203` statement\n```\nh : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))\n```\nIt replaces `h` with:\n1. a new string variable `z` and\n2. a new hypothesis `hz : derivable (M :: (z ++ \"M\"))`.\n\nWe then take `z` in place of `s` and `t` to prove the target.\n-/\n\n/- Example : no-side-bar\nGiven that there exists a string `x` such that `M :: (x ++ \"M\")` is derivable,\nthere exist strings `s` and `t` such that `M :: s ++ \"M\" ++ (t ++ \"M\")` is derivable.\n-/\nexample (h : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))) :\n\u2203 (s t : miustr), derivable (M :: s ++ \"M\" ++ (t ++ \"M\")) :=\nbegin\n  cases h with z hz,\n  use [z, z],\n  apply rule2 (z ++ \"M\"),\n  from hz,\nend\n\n\n/- Tactic : cases\n## Summary\n`cases` is used to decompose a hypothesis.\n\n## Detail\nIf `h : p \u2228 q`, then `cases h with h1 h2` creates two new goals: (1) to prove the target under\nthe assumption `h1 : p` and (2) to prove the target under the assumption `h2 : q`.\n\nIf `h : \u2203 x, p x`, then `cases h with z hz` creates two new items in the context: (1) a\nvariable `z` and (2) the hypothesis `hz : p z`.\n-/\n\n\n/- Theorem : no-side-bar\nGiven there exists `x` such that `M :: (x ++ [I])` is derivable, we have that\nthere exists `y` such that `M :: (y ++ [I, U])` is derivable.\n-/\nexample (h : \u2203 x, derivable (M :: (x ++ [I]))) :\n\u2203 y, derivable (M :: (y ++ [I, U])) :=\nbegin\n", "proof": "  cases h with z hz,\n  use z,\n  apply rule1 (M :: z),\n  from hz,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 59, "name": "", "statement": "(h : \u2203 x, derivable (M :: (x ++ [I]))) :\n\u2203 y, derivable (M :: (y ++ [I, U]))"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "text", "content": "123"}, {"type": "text", "content": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "axiom", "content": "127", "name": "repeat", "sideBar": true}, {"type": "theorem", "text": "128", "lean": "example (y z : miustr) : \u2203 y z, derivable (M :: y ++ \"UUU\" ++ z) :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 39, "textBefore": "import game.existence.level3 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 4 : Repeat\n-/\n\n/-\nThe expression `repeat x n` represents `n` repetitions of the letter `x`.\nThus `repeat U 3` is the string `\"UUU\"`.\nUse this together with the `::` and `++` notation to make your argument clearer.\n-/\n\n/- Hint : Hint!\nTake `y` to be `\"\"`, the empty string and take `z` to be a suitable string of `I`s.\nYou can do this only with rules 2 and 3 (and the base case).\n-/\n\n/- Axiom : repeat\nrepeat x n is n repetitions of the letter x.\n-/\n\n\n/- Theorem : no-side-bar\nThere exist strings y and z such that MyUUUz is derivable.\n-/\nexample (y z : miustr) : \u2203 y z, derivable (M :: y ++ \"UUU\" ++ z) :=\nbegin\n", "proof": "  have h1 : derivable (M :: repeat I 4), from rule2 _ der_MII,\n  have h2 : derivable (M :: repeat I 8), from rule2 _ h1,\n  have h3 : derivable (M :: repeat I 16), from rule2 _ h2,\n  have h4 : derivable (\"MU\" ++ repeat I 13), from rule3 \"M\" h3,\n  have h5 : derivable (\"MUU\" ++ repeat I 10), from rule3 \"MU\" h4,\n  have h6 : derivable (\"MUUU\" ++ repeat I 7), from rule3 \"MUU\" h5,\n  use [\"\", repeat I 7],\n  from h6,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n-- begin hide\nexample (y z : miustr) : \u2203 y z, derivable (M :: y ++ \"UUU\" ++ z) :=\nbegin\n  use [\"\", repeat I 7],\n  apply rule3 \"MUU\",\n  apply rule3 \"MU\",\n  apply rule3 \"M\",\n  apply rule2 (repeat I 8),\n  apply rule2 (repeat I 4),\n  apply rule2 (repeat I 2),\n  from der_MII,\n\n\nend\n-- end hide", "height": 10, "editorText": "sorry", "lineOffset": 29, "name": "", "statement": "(y z : miustr) : \u2203 y z, derivable (M :: y ++ \"UUU\" ++ z)"}, {"type": "lean", "content": "129", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "130", "hidden": true}, {"type": "lean", "content": "131", "hidden": true}, {"type": "text", "content": "132"}, {"type": "text", "content": "133"}, {"type": "hint", "content": "134", "title": "135"}, {"type": "theorem", "text": "136", "lean": "example (y : miustr) : \u2203 y, derivable (M :: y ++ \"UUU\" ++ y) :=\n", "sideBar": false, "firstProofLineNumber": 27, "lastProofLineNumber": 49, "textBefore": "import game.existence.level4 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 5 : A challenging existence example\n-/\n\n/-\nThis is a trickier variant of the previous level. We require that the 'bookends' of the string\nare equal.\n\nIf you get stuck, move on to the next world and come back later. Remember, we're trying to\ndetermine if `\"MU\"` can be derived.\n-/\n\n/- Hint : Hint!\nTake `y` to be `\"I\"`. You will need all four rules for this problem.\n-/\n\n\n/- Theorem : no-side-bar\nThere exists a string y such that MyUUUy is derivable.\n-/\nexample (y : miustr) : \u2203 y, derivable (M :: y ++ \"UUU\" ++ y) :=\nbegin\n", "proof": "  use \"I\",\n  apply rule3 \"MIUU\",\n  apply rule3 \"MIU\",\n  apply rule3 \"MI\",\n  apply rule4 (M :: repeat I 11),\n  apply rule4 (M :: repeat I 11),\n  apply rule4 (M :: repeat I 11),\n  apply rule4 (M :: repeat I 11),\n  apply rule3 (M :: repeat I 11),\n  apply rule3 (M :: repeat I 14),\n  apply rule3 (M :: repeat I 17),\n  apply rule3 (M :: repeat I 20),\n  apply rule3 (M :: repeat I 23),\n  apply rule3 (M :: repeat I 26),\n  apply rule3 (M :: repeat I 29),\n  apply rule1 (M :: repeat I 31),\n  apply rule2 (repeat I 16),\n  apply rule2 (repeat I 8),\n  apply rule2 (repeat I 4),\n  from rule2 \"II\" der_MII,\n  \n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n-- begin hide\nexample (y : miustr) : \u2203 y, derivable (M :: y ++ \"UUU\" ++ y) :=\nbegin\n  use \"I\",\n  have h1 : derivable (M :: repeat I 4), from rule2 _ der_MII,\n  have h2 : derivable (M :: repeat I 8), from rule2 _ h1,\n  have h3 : derivable (M :: repeat I 16), from rule2 _ h2,\n  have h4 : derivable (M :: repeat I 32), from rule2 _ h3,\n  have h5 : derivable (M :: repeat I 32 ++ \"U\"), from rule1 (M :: repeat I 31) h4,\n  have h6 : derivable (M :: repeat I 29 ++ \"UU\"), from rule3 (M :: repeat I 29) h5,\n  have h7 : derivable (M :: repeat I 26 ++ \"UUU\"), from rule3 (M :: repeat I 26) h6,\n  have h8 : derivable (M :: repeat I 23 ++ \"UUUU\"), from rule3 (M :: repeat I 23) h7,\n  have h9 : derivable (M :: repeat I 20 ++ \"UUUUU\"), from rule3 (M :: repeat I 20) h8,\n  have h10 : derivable (M :: repeat I 17 ++ repeat U 6), from rule3 (M :: repeat I 17) h9,\n  have h11 : derivable (M :: repeat I 14 ++ repeat U 7), from rule3 (M :: repeat I 14) h10,\n  have h12 : derivable (M :: repeat I 11 ++ repeat U 8), from rule3 (M :: repeat I 11) h11,\n  have h13 : derivable (M :: repeat I 11 ++ repeat U 6), from rule4 (M :: repeat I 11) h12,\n  have h14 : derivable (M :: repeat I 11 ++ repeat U 4), from rule4 (M :: repeat I 11) h13,\n  have h15 : derivable (M :: repeat I 11 ++ repeat U 2), from rule4 (M :: repeat I 11) h14,\n  have h16 : derivable (M :: repeat I 11), from rule4 (M :: repeat I 11) h15,\n  have h17 : derivable (\"MI\" ++ U :: repeat I 7), from rule3 \"MI\" h16,\n  have h18 : derivable (\"MI\" ++ \"UU\" ++ repeat I 4), from rule3 \"MIU\" h17,\n  from rule3 \"MIUU\" h18,\nend\n-- end hide", "height": 23, "editorText": "sorry", "lineOffset": 26, "name": "", "statement": "(y : miustr) : \u2203 y, derivable (M :: y ++ \"UUU\" ++ y)"}, {"type": "lean", "content": "137", "hidden": true}]}], "parents": [0]}, {"name": "138", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "139", "hidden": true}, {"type": "text", "content": "140"}, {"type": "text", "content": "141"}, {"type": "text", "content": "142"}, {"type": "example", "text": "144", "lean": "example (x y : \u2115) : x + y = x + y :=\n", "sideBar": false, "firstProofLineNumber": 34, "lastProofLineNumber": 34, "textBefore": "import game.existence.level5 -- hide\n\n/-\n## Level 1 : Reflexivity\n-/\n\n/-\nDespite the advances of the previous world, we've only been able to prove that strings _can_ be\nderived. How could we possibly show that a given string _cannot_ be derived?\n\nThe idea is to prove that every derivable string satisfies a certain easy-to-check property. If\na given string doesn't satisfy that property, then it isn't derivable!\n\nHere are some strings that we've derived so far. Can you spot a pattern?\n\n> MI, MIU, MIUIU, MUIU, MIUIUIUIU, MIIUIIUIIUIIU, MIIUU, MUUUIIIIIII.\n\nWe're searching for a numerical derivability criterion. To prepare you, we'll spend this world\nlooking at equations in Lean.\n-/\n\n/-\n## Proving equality with refl\n\nWhen two things are identical, the proof of their equality can be proved with the `refl` tactic\n\n-/\n\n/- Example : no-side-bar\n\\\\(x + y = y + x\\\\)\n-/\nexample (x y : \u2115) : x + y = x + y :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : refl\n## Summary\n`refl` is used to show equality of identitcal terms.\n\n## Detail\n`refl` proves a target `x = y` if `x` is identical to `y`.\n\nIdentical here means either _exactly the same_ or equal by\ndefinition. For example `1 + 1` is, by definition of addition, equal to `2`.\nBut `x + y` is not (in general) defined to be equal to `y + x`.\n-/\n\n/- Theorem : no-side-bar\n$y + xy = y + xy$\n-/\nexample (x y : \u2115) : y + (x * y) = y + (x * y) :=\nbegin\n  refl,\n\n\nend\n", "height": 1, "editorText": "143", "lineOffset": 33, "statement": "(x y : \u2115) : x + y = x + y"}, {"type": "tactic", "content": "145", "name": "refl", "sideBar": true}, {"type": "theorem", "text": "146", "lean": "example (x y : \u2115) : y + (x * y) = y + (x * y) :=\n", "sideBar": false, "firstProofLineNumber": 54, "lastProofLineNumber": 56, "textBefore": "import game.existence.level5 -- hide\n\n/-\n## Level 1 : Reflexivity\n-/\n\n/-\nDespite the advances of the previous world, we've only been able to prove that strings _can_ be\nderived. How could we possibly show that a given string _cannot_ be derived?\n\nThe idea is to prove that every derivable string satisfies a certain easy-to-check property. If\na given string doesn't satisfy that property, then it isn't derivable!\n\nHere are some strings that we've derived so far. Can you spot a pattern?\n\n> MI, MIU, MIUIU, MUIU, MIUIUIUIU, MIIUIIUIIUIIU, MIIUU, MUUUIIIIIII.\n\nWe're searching for a numerical derivability criterion. To prepare you, we'll spend this world\nlooking at equations in Lean.\n-/\n\n/-\n## Proving equality with refl\n\nWhen two things are identical, the proof of their equality can be proved with the `refl` tactic\n\n-/\n\n/- Example : no-side-bar\n\\\\(x + y = y + x\\\\)\n-/\nexample (x y : \u2115) : x + y = x + y :=\nbegin\n  refl,\nend\n\n/- Tactic : refl\n## Summary\n`refl` is used to show equality of identitcal terms.\n\n## Detail\n`refl` proves a target `x = y` if `x` is identical to `y`.\n\nIdentical here means either _exactly the same_ or equal by\ndefinition. For example `1 + 1` is, by definition of addition, equal to `2`.\nBut `x + y` is not (in general) defined to be equal to `y + x`.\n-/\n\n/- Theorem : no-side-bar\n$y + xy = y + xy$\n-/\nexample (x y : \u2115) : y + (x * y) = y + (x * y) :=\nbegin\n", "proof": "  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 53, "name": "", "statement": "(x y : \u2115) : y + (x * y) = y + (x * y)"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "147", "hidden": true}, {"type": "text", "content": "148"}, {"type": "text", "content": "149"}, {"type": "example", "text": "151", "lean": "example (x : \u2115) (h : x = 3) : 10 + 2 * x = 16 :=\n", "sideBar": false, "firstProofLineNumber": 20, "lastProofLineNumber": 21, "textBefore": "import game.numbers.level1 -- hide\n\n/-\n## Level 2 : Rewriting\n-/\n\n/-\nRewriting is used to make substitutions. Below, we show \\\\(10 + 2 x = 16\\\\) on the assumption `h`,\nthat \\\\(x = 3\\\\).\n\nTo do this, we rewrite the target with `h`, replacing `x` in the target with `3`.\n\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 3\\\\), then \\\\(10 + 2 x = 16\\\\).\n-/\nexample (x : \u2115) (h : x = 3) : 10 + 2 * x = 16 :=\nbegin\n", "proof": "  rw h,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : rw\n## Summary\n`rw`, the rewrite tactic, is used for substitutions.\n\n## Detail\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\nFor the next problem, you're given \\\\(y = 3\\\\) and you're asked to find \\\\(x\\\\) such that \n\\\\(20 + xy = 50.\\\\) You then need to prove equality.\n-/\n\n/- Hint : Hint\nYou'll need the `use`, `rw`, and `refl` tactics to prove the following result.\n\nYou can choose whether to do `use` or `rw` first. Try both approaches. Which is easier?\n-/\n\n/- Theorem : no-side-bar\nGiven \\\\(y = 3\\\\), there exists an integer \\\\(x\\\\), such that  \\\\(20 + xy = 50.\\\\)\n-/\nexample (y : \u2124) (h : y = 3) : \u2203 x, 20 + x * y = 50 :=\nbegin\n  use 10,\n  rw h,\n  refl,\n\n\nend\n", "height": 2, "editorText": "150", "lineOffset": 19, "statement": "(x : \u2115) (h : x = 3) : 10 + 2 * x = 16"}, {"type": "tactic", "content": "152", "name": "rw", "sideBar": true}, {"type": "text", "content": "153"}, {"type": "hint", "content": "154", "title": "155"}, {"type": "theorem", "text": "156", "lean": "example (y : \u2124) (h : y = 3) : \u2203 x, 20 + x * y = 50 :=\n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 59, "textBefore": "import game.numbers.level1 -- hide\n\n/-\n## Level 2 : Rewriting\n-/\n\n/-\nRewriting is used to make substitutions. Below, we show \\\\(10 + 2 x = 16\\\\) on the assumption `h`,\nthat \\\\(x = 3\\\\).\n\nTo do this, we rewrite the target with `h`, replacing `x` in the target with `3`.\n\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 3\\\\), then \\\\(10 + 2 x = 16\\\\).\n-/\nexample (x : \u2115) (h : x = 3) : 10 + 2 * x = 16 :=\nbegin\n  rw h,\n  refl,\nend\n\n\n/- Tactic : rw\n## Summary\n`rw`, the rewrite tactic, is used for substitutions.\n\n## Detail\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n-/\n\n/-\nFor the next problem, you're given \\\\(y = 3\\\\) and you're asked to find \\\\(x\\\\) such that \n\\\\(20 + xy = 50.\\\\) You then need to prove equality.\n-/\n\n/- Hint : Hint\nYou'll need the `use`, `rw`, and `refl` tactics to prove the following result.\n\nYou can choose whether to do `use` or `rw` first. Try both approaches. Which is easier?\n-/\n\n/- Theorem : no-side-bar\nGiven \\\\(y = 3\\\\), there exists an integer \\\\(x\\\\), such that  \\\\(20 + xy = 50.\\\\)\n-/\nexample (y : \u2124) (h : y = 3) : \u2203 x, 20 + x * y = 50 :=\nbegin\n", "proof": "  use 10,\n  rw h,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 54, "name": "", "statement": "(y : \u2124) (h : y = 3) : \u2203 x, 20 + x * y = 50"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "157", "hidden": true}, {"type": "text", "content": "158"}, {"type": "text", "content": "159"}, {"type": "example", "text": "161", "lean": "example (x : \u2124) : x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\n", "sideBar": false, "firstProofLineNumber": 16, "lastProofLineNumber": 16, "textBefore": "import game.numbers.level2 tactic.ring -- hide\n\n/-\n## Level 3 : Proving equations with the ring tactic\n-/\n\n/-\nThe `ring` tactic proves many polynomial identities.\n-/\n\n/- Example : no-side-bar\n\\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2,\\\\) for every integer \\\\(x.\\\\)\n-/\nexample (x : \u2124) : x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n", "proof": "  ring,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : ring\n## Summary\n`ring` proves many polynomial identities.\n-/\n\n\n\n/- Theorem : no-side-bar\nThere exists an integer \\\\(a\\\\) such that  \\\\( (x-1)^3 = x ^ 3 - ax ^2 + a x - 1,\\\\) for\nevery integer \\\\(x.\\\\)\n-/\nexample (x : \u2124) : \u2203 a, (x - 1) ^ 3 = x ^ 3 - a * x ^ 2 + a * x - 1 :=\nbegin\n  use 3,\n  ring,\n\n\nend\n", "height": 1, "editorText": "160", "lineOffset": 15, "statement": "(x : \u2124) : x ^ 2 - 2 * x + 1 = (x - 1) ^ 2"}, {"type": "tactic", "content": "162", "name": "ring", "sideBar": true}, {"type": "theorem", "text": "163", "lean": "example (x : \u2124) : \u2203 a, (x - 1) ^ 3 = x ^ 3 - a * x ^ 2 + a * x - 1 :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 36, "textBefore": "import game.numbers.level2 tactic.ring -- hide\n\n/-\n## Level 3 : Proving equations with the ring tactic\n-/\n\n/-\nThe `ring` tactic proves many polynomial identities.\n-/\n\n/- Example : no-side-bar\n\\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2,\\\\) for every integer \\\\(x.\\\\)\n-/\nexample (x : \u2124) : x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  ring,\nend\n\n\n/- Tactic : ring\n## Summary\n`ring` proves many polynomial identities.\n-/\n\n\n\n/- Theorem : no-side-bar\nThere exists an integer \\\\(a\\\\) such that  \\\\( (x-1)^3 = x ^ 3 - ax ^2 + a x - 1,\\\\) for\nevery integer \\\\(x.\\\\)\n-/\nexample (x : \u2124) : \u2203 a, (x - 1) ^ 3 = x ^ 3 - a * x ^ 2 + a * x - 1 :=\nbegin\n", "proof": "  use 3,\n  ring,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 32, "name": "", "statement": "(x : \u2124) : \u2203 a, (x - 1) ^ 3 = x ^ 3 - a * x ^ 2 + a * x - 1"}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "164", "hidden": true}, {"type": "text", "content": "165"}, {"type": "text", "content": "166"}, {"type": "text", "content": "167"}, {"type": "example", "text": "169", "lean": "example : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\n", "sideBar": false, "firstProofLineNumber": 35, "lastProofLineNumber": 37, "textBefore": "import game.numbers.level3 tactic.ring -- hide\n\n/-\n## Level 4 : Making assumptions\n-/\n\n/-\nDuring a proof, the top-right pane shows the goal(s). A goal consists of two things:\n\n1. The set of hypotheses up to that point in the proof. This includes the variables introduced\nat the start of the proof, any other initial assumptions, and hypotheses introduced via `have`\nor other mechanisms.\n\n2. The target. This is what you're trying to prove. It's marked with that `\u22a2` symbol, which\nis read 'to prove' or 'to construct'.\n-/\n\n/-\nSo far, all variables have been introduced into the context before the proof begins. We do this by\nlisting the variables to the left of the colon (`:`) symbol.\n\nSometimes, it's necessary to introduce variables and other hypotheses _during_ a proof.\n\nWe do this using the `assume` tactic.\n\nIn the example below, the symbol `\u2200` means 'for all' or 'for every'. It's typed `\\all`.\nThe symbol `\u2124` is typed `\\int` and stands for the integers.\n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n", "proof": "  assume x : \u2124, -- Assume `x` is an integer.\n  -- The target is `\u22a2 x ^ 2 - 2 * x + 1 = (x - 1) ^ 2`\n  ring,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nWhen using `assume`, the choice of variable name does not need to match the variable name\nin the 'for all' statement.\n\nThis is because (for example) `\u2200 (x y : \u2124), x + y = y + x` has _the same meaning_ as\n`\u2200 (s t : \u2124), s + t = t + s`. \n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume s : \u2124, -- Assume `s` is an integer.\n  -- The target is `\u22a2 s ^ 2 - 2 * s + 1 = (s - 1) ^ 2`\n  ring,\nend\n\n/-\nThe `assume` tactic can be used to introduce hypotheses too.\nThe statement\n```\nx = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25\n```\nis read 'if \\\\(x = y + 5,\\\\) then \\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\)'\n\nMore generally, `p \u2192 q` means 'if `p`, then `q`'.\n-/\n\n\n/- Example : no-side-bar\nFor all integers \\\\(x\\\\) and \\\\(y,\\\\) if \\\\(x = y + 5,\\\\) then\n\\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\) \n-/\nexample : \u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25 :=\nbegin\n  assume x y : \u2124, -- Assume `x` and `y` are integers.\n  assume h : x = y + 5, -- Assume `h`, that `x = y + 5`.\n  rw h, -- Substitute `y + 5` for `x` in the target\n  ring, -- Prove `(y + 5) ^ 2 = y ^ 2 + 10 * y + 25`.\nend\n\n\n/- Tactic : assume\n## Summary\n`assume` introduces a variable or hypothesis into the context.\n## Examples\n`assume x : \u2124` introduces the assumption that `x` is an integer.\n\n`assume h : x + 2 = 5` introduces the hypothesis `h` that `x + 2 = 5`.\n-/\n\n\n/-\nAs you work on the problem below, note how the context changes with each assumption.\n\nIf you do the problem by introducing variables called `s` and `t`, try it again with\ndifferent variable names.\n-/\n\n/- Hint : Hint\nStart with `assume s t : \u2124` or, if you're feeling adventurous, `assume x y : \u2124` \n-/\n\n\n/- Theorem : no-side-bar\nFor all integers \\\\(s\\\\) and \\\\(t,\\\\), if \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 7,\\\\) then \\\\(5st = 350.\\\\)\n-/\nexample : \u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350 :=\nbegin\n  assume s t : \u2124,\n  assume h\u2081 : s = t + 3,\n  assume h\u2082 : t = 7,\n  rw [h\u2081, h\u2082],\n  ring,\n\n\nend\n", "height": 3, "editorText": "168", "lineOffset": 34, "statement": "\u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2"}, {"type": "text", "content": "170"}, {"type": "example", "text": "172", "lean": "example : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\n", "sideBar": false, "firstProofLineNumber": 53, "lastProofLineNumber": 55, "textBefore": "import game.numbers.level3 tactic.ring -- hide\n\n/-\n## Level 4 : Making assumptions\n-/\n\n/-\nDuring a proof, the top-right pane shows the goal(s). A goal consists of two things:\n\n1. The set of hypotheses up to that point in the proof. This includes the variables introduced\nat the start of the proof, any other initial assumptions, and hypotheses introduced via `have`\nor other mechanisms.\n\n2. The target. This is what you're trying to prove. It's marked with that `\u22a2` symbol, which\nis read 'to prove' or 'to construct'.\n-/\n\n/-\nSo far, all variables have been introduced into the context before the proof begins. We do this by\nlisting the variables to the left of the colon (`:`) symbol.\n\nSometimes, it's necessary to introduce variables and other hypotheses _during_ a proof.\n\nWe do this using the `assume` tactic.\n\nIn the example below, the symbol `\u2200` means 'for all' or 'for every'. It's typed `\\all`.\nThe symbol `\u2124` is typed `\\int` and stands for the integers.\n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume x : \u2124, -- Assume `x` is an integer.\n  -- The target is `\u22a2 x ^ 2 - 2 * x + 1 = (x - 1) ^ 2`\n  ring,\nend\n\n/-\nWhen using `assume`, the choice of variable name does not need to match the variable name\nin the 'for all' statement.\n\nThis is because (for example) `\u2200 (x y : \u2124), x + y = y + x` has _the same meaning_ as\n`\u2200 (s t : \u2124), s + t = t + s`. \n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n", "proof": "  assume s : \u2124, -- Assume `s` is an integer.\n  -- The target is `\u22a2 s ^ 2 - 2 * s + 1 = (s - 1) ^ 2`\n  ring,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nThe `assume` tactic can be used to introduce hypotheses too.\nThe statement\n```\nx = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25\n```\nis read 'if \\\\(x = y + 5,\\\\) then \\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\)'\n\nMore generally, `p \u2192 q` means 'if `p`, then `q`'.\n-/\n\n\n/- Example : no-side-bar\nFor all integers \\\\(x\\\\) and \\\\(y,\\\\) if \\\\(x = y + 5,\\\\) then\n\\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\) \n-/\nexample : \u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25 :=\nbegin\n  assume x y : \u2124, -- Assume `x` and `y` are integers.\n  assume h : x = y + 5, -- Assume `h`, that `x = y + 5`.\n  rw h, -- Substitute `y + 5` for `x` in the target\n  ring, -- Prove `(y + 5) ^ 2 = y ^ 2 + 10 * y + 25`.\nend\n\n\n/- Tactic : assume\n## Summary\n`assume` introduces a variable or hypothesis into the context.\n## Examples\n`assume x : \u2124` introduces the assumption that `x` is an integer.\n\n`assume h : x + 2 = 5` introduces the hypothesis `h` that `x + 2 = 5`.\n-/\n\n\n/-\nAs you work on the problem below, note how the context changes with each assumption.\n\nIf you do the problem by introducing variables called `s` and `t`, try it again with\ndifferent variable names.\n-/\n\n/- Hint : Hint\nStart with `assume s t : \u2124` or, if you're feeling adventurous, `assume x y : \u2124` \n-/\n\n\n/- Theorem : no-side-bar\nFor all integers \\\\(s\\\\) and \\\\(t,\\\\), if \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 7,\\\\) then \\\\(5st = 350.\\\\)\n-/\nexample : \u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350 :=\nbegin\n  assume s t : \u2124,\n  assume h\u2081 : s = t + 3,\n  assume h\u2082 : t = 7,\n  rw [h\u2081, h\u2082],\n  ring,\n\n\nend\n", "height": 3, "editorText": "171", "lineOffset": 52, "statement": "\u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2"}, {"type": "text", "content": "173"}, {"type": "example", "text": "175", "lean": "example : \u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25 :=\n", "sideBar": false, "firstProofLineNumber": 76, "lastProofLineNumber": 79, "textBefore": "import game.numbers.level3 tactic.ring -- hide\n\n/-\n## Level 4 : Making assumptions\n-/\n\n/-\nDuring a proof, the top-right pane shows the goal(s). A goal consists of two things:\n\n1. The set of hypotheses up to that point in the proof. This includes the variables introduced\nat the start of the proof, any other initial assumptions, and hypotheses introduced via `have`\nor other mechanisms.\n\n2. The target. This is what you're trying to prove. It's marked with that `\u22a2` symbol, which\nis read 'to prove' or 'to construct'.\n-/\n\n/-\nSo far, all variables have been introduced into the context before the proof begins. We do this by\nlisting the variables to the left of the colon (`:`) symbol.\n\nSometimes, it's necessary to introduce variables and other hypotheses _during_ a proof.\n\nWe do this using the `assume` tactic.\n\nIn the example below, the symbol `\u2200` means 'for all' or 'for every'. It's typed `\\all`.\nThe symbol `\u2124` is typed `\\int` and stands for the integers.\n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume x : \u2124, -- Assume `x` is an integer.\n  -- The target is `\u22a2 x ^ 2 - 2 * x + 1 = (x - 1) ^ 2`\n  ring,\nend\n\n/-\nWhen using `assume`, the choice of variable name does not need to match the variable name\nin the 'for all' statement.\n\nThis is because (for example) `\u2200 (x y : \u2124), x + y = y + x` has _the same meaning_ as\n`\u2200 (s t : \u2124), s + t = t + s`. \n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume s : \u2124, -- Assume `s` is an integer.\n  -- The target is `\u22a2 s ^ 2 - 2 * s + 1 = (s - 1) ^ 2`\n  ring,\nend\n\n/-\nThe `assume` tactic can be used to introduce hypotheses too.\nThe statement\n```\nx = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25\n```\nis read 'if \\\\(x = y + 5,\\\\) then \\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\)'\n\nMore generally, `p \u2192 q` means 'if `p`, then `q`'.\n-/\n\n\n/- Example : no-side-bar\nFor all integers \\\\(x\\\\) and \\\\(y,\\\\) if \\\\(x = y + 5,\\\\) then\n\\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\) \n-/\nexample : \u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25 :=\nbegin\n", "proof": "  assume x y : \u2124, -- Assume `x` and `y` are integers.\n  assume h : x = y + 5, -- Assume `h`, that `x = y + 5`.\n  rw h, -- Substitute `y + 5` for `x` in the target\n  ring, -- Prove `(y + 5) ^ 2 = y ^ 2 + 10 * y + 25`.", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : assume\n## Summary\n`assume` introduces a variable or hypothesis into the context.\n## Examples\n`assume x : \u2124` introduces the assumption that `x` is an integer.\n\n`assume h : x + 2 = 5` introduces the hypothesis `h` that `x + 2 = 5`.\n-/\n\n\n/-\nAs you work on the problem below, note how the context changes with each assumption.\n\nIf you do the problem by introducing variables called `s` and `t`, try it again with\ndifferent variable names.\n-/\n\n/- Hint : Hint\nStart with `assume s t : \u2124` or, if you're feeling adventurous, `assume x y : \u2124` \n-/\n\n\n/- Theorem : no-side-bar\nFor all integers \\\\(s\\\\) and \\\\(t,\\\\), if \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 7,\\\\) then \\\\(5st = 350.\\\\)\n-/\nexample : \u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350 :=\nbegin\n  assume s t : \u2124,\n  assume h\u2081 : s = t + 3,\n  assume h\u2082 : t = 7,\n  rw [h\u2081, h\u2082],\n  ring,\n\n\nend\n", "height": 4, "editorText": "174", "lineOffset": 75, "statement": "\u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25"}, {"type": "tactic", "content": "176", "name": "assume", "sideBar": true}, {"type": "text", "content": "177"}, {"type": "hint", "content": "178", "title": "179"}, {"type": "theorem", "text": "180", "lean": "example : \u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350 :=\n", "sideBar": false, "firstProofLineNumber": 111, "lastProofLineNumber": 117, "textBefore": "import game.numbers.level3 tactic.ring -- hide\n\n/-\n## Level 4 : Making assumptions\n-/\n\n/-\nDuring a proof, the top-right pane shows the goal(s). A goal consists of two things:\n\n1. The set of hypotheses up to that point in the proof. This includes the variables introduced\nat the start of the proof, any other initial assumptions, and hypotheses introduced via `have`\nor other mechanisms.\n\n2. The target. This is what you're trying to prove. It's marked with that `\u22a2` symbol, which\nis read 'to prove' or 'to construct'.\n-/\n\n/-\nSo far, all variables have been introduced into the context before the proof begins. We do this by\nlisting the variables to the left of the colon (`:`) symbol.\n\nSometimes, it's necessary to introduce variables and other hypotheses _during_ a proof.\n\nWe do this using the `assume` tactic.\n\nIn the example below, the symbol `\u2200` means 'for all' or 'for every'. It's typed `\\all`.\nThe symbol `\u2124` is typed `\\int` and stands for the integers.\n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume x : \u2124, -- Assume `x` is an integer.\n  -- The target is `\u22a2 x ^ 2 - 2 * x + 1 = (x - 1) ^ 2`\n  ring,\nend\n\n/-\nWhen using `assume`, the choice of variable name does not need to match the variable name\nin the 'for all' statement.\n\nThis is because (for example) `\u2200 (x y : \u2124), x + y = y + x` has _the same meaning_ as\n`\u2200 (s t : \u2124), s + t = t + s`. \n-/\n\n/- Example : no-side-bar\nFor every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n-/\nexample : \u2200 (x : \u2124), x ^ 2 - 2 * x + 1 = (x - 1) ^ 2 :=\nbegin\n  assume s : \u2124, -- Assume `s` is an integer.\n  -- The target is `\u22a2 s ^ 2 - 2 * s + 1 = (s - 1) ^ 2`\n  ring,\nend\n\n/-\nThe `assume` tactic can be used to introduce hypotheses too.\nThe statement\n```\nx = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25\n```\nis read 'if \\\\(x = y + 5,\\\\) then \\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\)'\n\nMore generally, `p \u2192 q` means 'if `p`, then `q`'.\n-/\n\n\n/- Example : no-side-bar\nFor all integers \\\\(x\\\\) and \\\\(y,\\\\) if \\\\(x = y + 5,\\\\) then\n\\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\) \n-/\nexample : \u2200 (x y : \u2124), x = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25 :=\nbegin\n  assume x y : \u2124, -- Assume `x` and `y` are integers.\n  assume h : x = y + 5, -- Assume `h`, that `x = y + 5`.\n  rw h, -- Substitute `y + 5` for `x` in the target\n  ring, -- Prove `(y + 5) ^ 2 = y ^ 2 + 10 * y + 25`.\nend\n\n\n/- Tactic : assume\n## Summary\n`assume` introduces a variable or hypothesis into the context.\n## Examples\n`assume x : \u2124` introduces the assumption that `x` is an integer.\n\n`assume h : x + 2 = 5` introduces the hypothesis `h` that `x + 2 = 5`.\n-/\n\n\n/-\nAs you work on the problem below, note how the context changes with each assumption.\n\nIf you do the problem by introducing variables called `s` and `t`, try it again with\ndifferent variable names.\n-/\n\n/- Hint : Hint\nStart with `assume s t : \u2124` or, if you're feeling adventurous, `assume x y : \u2124` \n-/\n\n\n/- Theorem : no-side-bar\nFor all integers \\\\(s\\\\) and \\\\(t,\\\\), if \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 7,\\\\) then \\\\(5st = 350.\\\\)\n-/\nexample : \u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350 :=\nbegin\n", "proof": "  assume s t : \u2124,\n  assume h\u2081 : s = t + 3,\n  assume h\u2082 : t = 7,\n  rw [h\u2081, h\u2082],\n  ring,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 110, "name": "", "statement": "\u2200 (s t : \u2124), s = t + 3 \u2192 t = 7 \u2192 5 * s * t = 350"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "181", "hidden": true}, {"type": "text", "content": "182"}, {"type": "text", "content": "183"}, {"type": "hint", "content": "184", "title": "185"}, {"type": "theorem", "text": "186", "lean": "example : \u2203 (a : \u2124), \u2200 (s t : \u2124), s = t + 3 \u2192 t = 4 \u2192 2 * s * t = a :=\n", "sideBar": false, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "import game.numbers.level4 tactic.ring -- hide\n\n/-\n## Level 5 : Mixing 'there exists' and 'for all'\n-/\n\n/-\nThe statement of the next problem starts with `\u2203`. Thus, the first thing you must do,\nbefore introducing assumptions, is to find  `a`.\n-/\n\n/- Hint : Hint\nStart with the `use` tactic.\n-/\n\n\n\n/- Theorem : no-side-bar\nThere exists an integer \\\\(a\\\\) such that for all integers \\\\(s\\\\) and \\\\(t,\\\\)\nif \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 4,\\\\) then \\\\(2st = a.\\\\)\n-/\nexample : \u2203 (a : \u2124), \u2200 (s t : \u2124), s = t + 3 \u2192 t = 4 \u2192 2 * s * t = a :=\nbegin\n", "proof": "  use 56,\n  assume s t : \u2124,\n  assume h\u2081 : s = t + 3,\n  assume h\u2082 : t = 4,\n  rw [h\u2081, h\u2082],\n  ring,\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "", "statement": "\u2203 (a : \u2124), \u2200 (s t : \u2124), s = t + 3 \u2192 t = 4 \u2192 2 * s * t = a"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "187", "hidden": true}, {"type": "text", "content": "188"}, {"type": "text", "content": "189"}, {"type": "text", "content": "190"}, {"type": "example", "text": "192", "lean": "example (x : \u2124) (h : x = 1 \u2228 x = 2) : x ^ 2 - 3 * x + 2 = 0 :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 35, "textBefore": "import game.numbers.level5  -- hide\n\n/-\n## Level 6 : This or that\n-/\n\n/-\nOften, we are told that one thing _or_ another thing happens. If I know you like tea or you like\ncoffee, I definitely know you like a bitter-flavoured drink. In the mathematical world, a\nperson who likes tea or coffee might like both tea _and_ coffee.\n-/\n\n/-\nIn this example, we prove that if \\\\(x = 1 \\lor x = 2,\\\\)  then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n The symbol `\u2228` (typed `\\or`) means 'or'. Thus, `h : x = 1 \u2228 x = 2` is the hypothesis that\n `x = 1` or `x = 2`.\n\nTo use this hypothesis, we consider the cases `x = 1` and `x = 2` separately.\nThe `cases` tactic splits `h` into two cases (which we've called `hl` and `hr`) and creates\ntwo new goals: (1) to prove the target under the assumption `hl : x = 1` and (2) to prove the\ntarget under the assumption `hr : x = 2`.\n\nIn the first case, for example, after `rw hl`, the target is to prove `1 ^ 2 - 3 * 1 + 2 = 0`.\n\nBraces are used here to separate the two goals.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 1 \\lor x = 2,\\\\) then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n-/\nexample (x : \u2124) (h : x = 1 \u2228 x = 2) : x ^ 2 - 3 * x + 2 = 0 :=\nbegin\n", "proof": "  cases h with hl hr, -- Text after a -- is a comment and is ignored.\n  { rw hl, refl, }, -- This is the case `x = 1`.\n  { rw hr, refl, }, -- This is the case `x = 2`.", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Theorem : no-side-bar\nThere exists an integer \\\\(a\\\\) such that for all integers \\\\(x,\\\\) and \\\\(y,\\\\)\nif \\\\(x = 3 \u2228 y = -5,\\\\) then \\\\(x y + 3x - 3y = a.\\\\)\n-/\nexample : \u2203 (a : \u2124), \u2200 (x y : \u2124), x = 3 \u2228 y = -5 \u2192\n x * y + 5 * x - 3 * y = a :=\nbegin\n  use 15,\n  assume x y : \u2124,\n  assume h : x = 3 \u2228 y = -5,\n  cases h with hl hr,\n  { rw hl, ring, },\n  { rw hr, ring, },\n\n\nend\n", "height": 3, "editorText": "191", "lineOffset": 32, "statement": "(x : \u2124) (h : x = 1 \u2228 x = 2) : x ^ 2 - 3 * x + 2 = 0"}, {"type": "theorem", "text": "193", "lean": "example : \u2203 (a : \u2124), \u2200 (x y : \u2124), x = 3 \u2228 y = -5 \u2192\n x * y + 5 * x - 3 * y = a :=\n", "sideBar": false, "firstProofLineNumber": 45, "lastProofLineNumber": 52, "textBefore": "import game.numbers.level5  -- hide\n\n/-\n## Level 6 : This or that\n-/\n\n/-\nOften, we are told that one thing _or_ another thing happens. If I know you like tea or you like\ncoffee, I definitely know you like a bitter-flavoured drink. In the mathematical world, a\nperson who likes tea or coffee might like both tea _and_ coffee.\n-/\n\n/-\nIn this example, we prove that if \\\\(x = 1 \\lor x = 2,\\\\)  then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n The symbol `\u2228` (typed `\\or`) means 'or'. Thus, `h : x = 1 \u2228 x = 2` is the hypothesis that\n `x = 1` or `x = 2`.\n\nTo use this hypothesis, we consider the cases `x = 1` and `x = 2` separately.\nThe `cases` tactic splits `h` into two cases (which we've called `hl` and `hr`) and creates\ntwo new goals: (1) to prove the target under the assumption `hl : x = 1` and (2) to prove the\ntarget under the assumption `hr : x = 2`.\n\nIn the first case, for example, after `rw hl`, the target is to prove `1 ^ 2 - 3 * 1 + 2 = 0`.\n\nBraces are used here to separate the two goals.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 1 \\lor x = 2,\\\\) then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n-/\nexample (x : \u2124) (h : x = 1 \u2228 x = 2) : x ^ 2 - 3 * x + 2 = 0 :=\nbegin\n  cases h with hl hr, -- Text after a -- is a comment and is ignored.\n  { rw hl, refl, }, -- This is the case `x = 1`.\n  { rw hr, refl, }, -- This is the case `x = 2`.\nend\n\n/- Theorem : no-side-bar\nThere exists an integer \\\\(a\\\\) such that for all integers \\\\(x,\\\\) and \\\\(y,\\\\)\nif \\\\(x = 3 \u2228 y = -5,\\\\) then \\\\(x y + 3x - 3y = a.\\\\)\n-/\nexample : \u2203 (a : \u2124), \u2200 (x y : \u2124), x = 3 \u2228 y = -5 \u2192\n x * y + 5 * x - 3 * y = a :=\nbegin\n", "proof": "  use 15,\n  assume x y : \u2124,\n  assume h : x = 3 \u2228 y = -5,\n  cases h with hl hr,\n  { rw hl, ring, },\n  { rw hr, ring, },\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 44, "name": "", "statement": "\u2203 (a : \u2124), \u2200 (x y : \u2124), x = 3 \u2228 y = -5 \u2192\n x * y + 5 * x - 3 * y = a"}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "194", "hidden": true}, {"type": "text", "content": "195"}, {"type": "text", "content": "196"}, {"type": "text", "content": "197"}, {"type": "example", "text": "199", "lean": "example (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\n", "sideBar": false, "firstProofLineNumber": 28, "lastProofLineNumber": 30, "textBefore": "import game.numbers.level6  -- hide\n\n/-\n## Level 7 : Proving 'or' statements\n-/\n\n/-\nWe've seen the `cases` tactic used to analyse a given 'or' statement.\nBut how do we _prove_ an or statement?\n\nIf I want to prove you like tea or you like coffee, it suffices to prove that you like tea.\nThat is, it suffices to prove the 'left' part of the or statement.\n\nLikewise, it would also suffice for me to prove the right part of the statement.\n-/\n\n/-\nThe `left` and `right` tactics are used to specify which side of the statement we want to prove.\nTyping `left` below changes the target from one of proving `x = 1 \u2228 x = 2` to one of proving\n`x = 1`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 1,\\\\) then \\\\(x = 1 \\lor x = 2.\\\\)\n-/\nexample (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\nbegin\n", "proof": "  left,\n  from h,\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nTo help your reader, use the `show` tactic. This makes explicit what it is you're showing.\n-/\n\nexample (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\nbegin\n  left,\n  show x = 1, from h,\n\nend\n\n/- Tactic : show\n`show` is used to specify the target.\n## Summary\nIf the target is `\u22a2 p`, type `show p` to relay this information to the reader.\n-/\n\n\n/- Tactic : left\n## Summary\n`left` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `left` changes the target to one of proving `p`.\n-/\n\n/- Tactic : right\n## Summary\n`right` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `right` changes the target to one of proving `q`.\n-/\n\n/- Hint: Hint\nYou'll need one of `left` or `right`, followed by applications of `rw` and `refl`. \n-/\n\n\n/- Theorem : no-side-bar\nGiven \\\\(x = 3,\\\\) we have \\\\(x + 3 = 7\\\\) or \\\\(4x = 12.\\\\)\n-/\nexample (x : \u2124) (h : x = 3) : (x + 3 = 7) \u2228 (4 * x = 12) :=\nbegin\n  right,\n  rw h,\n  refl,\n\n\nend\n", "height": 3, "editorText": "198", "lineOffset": 27, "statement": "(x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2"}, {"type": "text", "content": "200"}, {"type": "lean", "content": "201", "hidden": false}, {"type": "tactic", "content": "202", "name": "show", "sideBar": true}, {"type": "tactic", "content": "203", "name": "left", "sideBar": true}, {"type": "tactic", "content": "204", "name": "right", "sideBar": true}, {"type": "hint", "content": "205", "title": "206"}, {"type": "theorem", "text": "207", "lean": "example (x : \u2124) (h : x = 3) : (x + 3 = 7) \u2228 (4 * x = 12) :=\n", "sideBar": false, "firstProofLineNumber": 77, "lastProofLineNumber": 81, "textBefore": "import game.numbers.level6  -- hide\n\n/-\n## Level 7 : Proving 'or' statements\n-/\n\n/-\nWe've seen the `cases` tactic used to analyse a given 'or' statement.\nBut how do we _prove_ an or statement?\n\nIf I want to prove you like tea or you like coffee, it suffices to prove that you like tea.\nThat is, it suffices to prove the 'left' part of the or statement.\n\nLikewise, it would also suffice for me to prove the right part of the statement.\n-/\n\n/-\nThe `left` and `right` tactics are used to specify which side of the statement we want to prove.\nTyping `left` below changes the target from one of proving `x = 1 \u2228 x = 2` to one of proving\n`x = 1`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x = 1,\\\\) then \\\\(x = 1 \\lor x = 2.\\\\)\n-/\nexample (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\nbegin\n  left,\n  from h,\n\nend\n\n/-\nTo help your reader, use the `show` tactic. This makes explicit what it is you're showing.\n-/\n\nexample (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\nbegin\n  left,\n  show x = 1, from h,\n\nend\n\n/- Tactic : show\n`show` is used to specify the target.\n## Summary\nIf the target is `\u22a2 p`, type `show p` to relay this information to the reader.\n-/\n\n\n/- Tactic : left\n## Summary\n`left` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `left` changes the target to one of proving `p`.\n-/\n\n/- Tactic : right\n## Summary\n`right` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `right` changes the target to one of proving `q`.\n-/\n\n/- Hint: Hint\nYou'll need one of `left` or `right`, followed by applications of `rw` and `refl`. \n-/\n\n\n/- Theorem : no-side-bar\nGiven \\\\(x = 3,\\\\) we have \\\\(x + 3 = 7\\\\) or \\\\(4x = 12.\\\\)\n-/\nexample (x : \u2124) (h : x = 3) : (x + 3 = 7) \u2228 (4 * x = 12) :=\nbegin\n", "proof": "  right,\n  rw h,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 76, "name": "", "statement": "(x : \u2124) (h : x = 3) : (x + 3 = 7) \u2228 (4 * x = 12)"}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "208", "hidden": true}, {"type": "text", "content": "209"}, {"type": "text", "content": "210"}, {"type": "text", "content": "211"}, {"type": "example", "text": "213", "lean": "example (x y : \u2124) (h : x * y = 0) : x = 0 \u2228 y = 0 :=\n", "sideBar": false, "firstProofLineNumber": 24, "lastProofLineNumber": 27, "textBefore": "import game.numbers.level7 tactic.linarith -- hide\n\n/-\n## Level 8 : Solutions of equations\n-/\n\n/-\nFactorisation is a common technique for solving equations.\n\nIt depends on the fact that \\\\(xy = 0\\\\) if and only if \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\nThis fact is called `mul_eq_zero` in Lean. We can use it for rewriting.\n-/\n\n/-\nIn the example below, we rewrite at `h` rather than at the target. That's because `h` matches\nthe left side of `mul_eq_zero`.\n-/\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) then \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) : x = 0 \u2228 y = 0 :=\nbegin\n", "proof": "  -- The `rw` line changes `h` to `x = 0 \u2228 y = 0`.\n  rw mul_eq_zero at h,\n  from h,\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nA one-line proof of the above is `rwa mul_eq_zero at h`. The `rwa` performs a rewrite then tries\nto close the goal using the hypotheses. In this case, it succeeds with hypothesis `h`.\n-/\n\n\n/- Axiom : mul_eq_zero\nx * y = 0 \u2194 x = 0 \u2228 y = 0\n-/\n\n/- Tactic : linarith\n## Summary \n`linarith` solves linear equations and inequalities.\n## Detail\nThe linarith tactic will automatically use any hypotheses in the context to help it close the goal.\n-/\n\n/-\nIn the next example, we use the `linarith` tactic. This powerful tactic solves 'linear' equations and\ninequalities. By default, it will use any hypothesis in the context. Here, it solves the target `x = 7`\nusing the hypothesis `h : x - 7 = 0`.\n\nWe use the `ring` tactic to express equation `h` as a product. Note there is no `from` to match with `have`.\nThis is because `ring` is a tactic, not a proof term.\n-/\n\n\n/- Example : no-side-bar\nIf \\\\(x y - 7y = 0,\\\\) then \\\\(x = 7\\\\) or \\\\(y = 0.\\\\) \n-/\nexample (x y : \u2124) (h : x * y - 7 * y = 0) : x = 7 \u2228 y = 0 :=\nbegin\n  have h1 : x * y - 7 * y = y * (x - 7), ring,\n  -- After the `rw`, `h` becomes `y = 0 \u2228 x - 7 = 0`.\n  rw [h1, mul_eq_zero] at h,\n  cases h with hl hr,\n  { right,            -- The case `y = 0`.\n    show y = 0, from hl, }, \n  { left,             -- The case `x - 7 = 0`.\n    show x = 7,\n    linarith, },\nend\n\n\n\n\n/-\nAdapt the proof of the example above to find \\\\(a\\\\) and \\\\(b\\\\) such that if  \\\\(x ^ 2 - 3 x + 2 = 0,\\\\)\nthen \\\\(x = a\\\\) or \\\\(x = b.\\\\)\n-/\n\n\n/- Theorem : no-side-bar\nGiven \\\\(x ^ 2 - 3 x + 2 = 0,\\\\) there exist integers \\\\(a\\\\) and \\\\(b\\\\) sucht that \\\\(x = a\\\\)\nor \\\\(x = b.\\\\)\n-/\nexample (x : \u2124) (h : x ^ 2 - 3 * x + 2 = 0) : \u2203 a b, x = a \u2228 x = b :=\nbegin\n  have h1 : x ^ 2 - 3 * x + 2 = (x - 1) * (x - 2), ring,\n  rw h1 at h,\n  rw mul_eq_zero at h,\n  use [1, 2],\n  cases h,\n  { left, \n    linarith, },\n  { right,\n    linarith, },\n\n\n\nend\n", "height": 4, "editorText": "212", "lineOffset": 23, "statement": "(x y : \u2124) (h : x * y = 0) : x = 0 \u2228 y = 0"}, {"type": "text", "content": "214"}, {"type": "axiom", "content": "215", "name": "mul_eq_zero", "sideBar": true}, {"type": "tactic", "content": "216", "name": "linarith", "sideBar": true}, {"type": "text", "content": "217"}, {"type": "example", "text": "219", "lean": "example (x y : \u2124) (h : x * y - 7 * y = 0) : x = 7 \u2228 y = 0 :=\n", "sideBar": false, "firstProofLineNumber": 62, "lastProofLineNumber": 70, "textBefore": "import game.numbers.level7 tactic.linarith -- hide\n\n/-\n## Level 8 : Solutions of equations\n-/\n\n/-\nFactorisation is a common technique for solving equations.\n\nIt depends on the fact that \\\\(xy = 0\\\\) if and only if \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\nThis fact is called `mul_eq_zero` in Lean. We can use it for rewriting.\n-/\n\n/-\nIn the example below, we rewrite at `h` rather than at the target. That's because `h` matches\nthe left side of `mul_eq_zero`.\n-/\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) then \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) : x = 0 \u2228 y = 0 :=\nbegin\n  -- The `rw` line changes `h` to `x = 0 \u2228 y = 0`.\n  rw mul_eq_zero at h,\n  from h,\n\nend\n\n/-\nA one-line proof of the above is `rwa mul_eq_zero at h`. The `rwa` performs a rewrite then tries\nto close the goal using the hypotheses. In this case, it succeeds with hypothesis `h`.\n-/\n\n\n/- Axiom : mul_eq_zero\nx * y = 0 \u2194 x = 0 \u2228 y = 0\n-/\n\n/- Tactic : linarith\n## Summary \n`linarith` solves linear equations and inequalities.\n## Detail\nThe linarith tactic will automatically use any hypotheses in the context to help it close the goal.\n-/\n\n/-\nIn the next example, we use the `linarith` tactic. This powerful tactic solves 'linear' equations and\ninequalities. By default, it will use any hypothesis in the context. Here, it solves the target `x = 7`\nusing the hypothesis `h : x - 7 = 0`.\n\nWe use the `ring` tactic to express equation `h` as a product. Note there is no `from` to match with `have`.\nThis is because `ring` is a tactic, not a proof term.\n-/\n\n\n/- Example : no-side-bar\nIf \\\\(x y - 7y = 0,\\\\) then \\\\(x = 7\\\\) or \\\\(y = 0.\\\\) \n-/\nexample (x y : \u2124) (h : x * y - 7 * y = 0) : x = 7 \u2228 y = 0 :=\nbegin\n", "proof": "  have h1 : x * y - 7 * y = y * (x - 7), ring,\n  -- After the `rw`, `h` becomes `y = 0 \u2228 x - 7 = 0`.\n  rw [h1, mul_eq_zero] at h,\n  cases h with hl hr,\n  { right,            -- The case `y = 0`.\n    show y = 0, from hl, }, \n  { left,             -- The case `x - 7 = 0`.\n    show x = 7,\n    linarith, },", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n/-\nAdapt the proof of the example above to find \\\\(a\\\\) and \\\\(b\\\\) such that if  \\\\(x ^ 2 - 3 x + 2 = 0,\\\\)\nthen \\\\(x = a\\\\) or \\\\(x = b.\\\\)\n-/\n\n\n/- Theorem : no-side-bar\nGiven \\\\(x ^ 2 - 3 x + 2 = 0,\\\\) there exist integers \\\\(a\\\\) and \\\\(b\\\\) sucht that \\\\(x = a\\\\)\nor \\\\(x = b.\\\\)\n-/\nexample (x : \u2124) (h : x ^ 2 - 3 * x + 2 = 0) : \u2203 a b, x = a \u2228 x = b :=\nbegin\n  have h1 : x ^ 2 - 3 * x + 2 = (x - 1) * (x - 2), ring,\n  rw h1 at h,\n  rw mul_eq_zero at h,\n  use [1, 2],\n  cases h,\n  { left, \n    linarith, },\n  { right,\n    linarith, },\n\n\n\nend\n", "height": 9, "editorText": "218", "lineOffset": 61, "statement": "(x y : \u2124) (h : x * y - 7 * y = 0) : x = 7 \u2228 y = 0"}, {"type": "text", "content": "220"}, {"type": "theorem", "text": "221", "lean": "example (x : \u2124) (h : x ^ 2 - 3 * x + 2 = 0) : \u2203 a b, x = a \u2228 x = b :=\n", "sideBar": false, "firstProofLineNumber": 88, "lastProofLineNumber": 99, "textBefore": "import game.numbers.level7 tactic.linarith -- hide\n\n/-\n## Level 8 : Solutions of equations\n-/\n\n/-\nFactorisation is a common technique for solving equations.\n\nIt depends on the fact that \\\\(xy = 0\\\\) if and only if \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\nThis fact is called `mul_eq_zero` in Lean. We can use it for rewriting.\n-/\n\n/-\nIn the example below, we rewrite at `h` rather than at the target. That's because `h` matches\nthe left side of `mul_eq_zero`.\n-/\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) then \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) : x = 0 \u2228 y = 0 :=\nbegin\n  -- The `rw` line changes `h` to `x = 0 \u2228 y = 0`.\n  rw mul_eq_zero at h,\n  from h,\n\nend\n\n/-\nA one-line proof of the above is `rwa mul_eq_zero at h`. The `rwa` performs a rewrite then tries\nto close the goal using the hypotheses. In this case, it succeeds with hypothesis `h`.\n-/\n\n\n/- Axiom : mul_eq_zero\nx * y = 0 \u2194 x = 0 \u2228 y = 0\n-/\n\n/- Tactic : linarith\n## Summary \n`linarith` solves linear equations and inequalities.\n## Detail\nThe linarith tactic will automatically use any hypotheses in the context to help it close the goal.\n-/\n\n/-\nIn the next example, we use the `linarith` tactic. This powerful tactic solves 'linear' equations and\ninequalities. By default, it will use any hypothesis in the context. Here, it solves the target `x = 7`\nusing the hypothesis `h : x - 7 = 0`.\n\nWe use the `ring` tactic to express equation `h` as a product. Note there is no `from` to match with `have`.\nThis is because `ring` is a tactic, not a proof term.\n-/\n\n\n/- Example : no-side-bar\nIf \\\\(x y - 7y = 0,\\\\) then \\\\(x = 7\\\\) or \\\\(y = 0.\\\\) \n-/\nexample (x y : \u2124) (h : x * y - 7 * y = 0) : x = 7 \u2228 y = 0 :=\nbegin\n  have h1 : x * y - 7 * y = y * (x - 7), ring,\n  -- After the `rw`, `h` becomes `y = 0 \u2228 x - 7 = 0`.\n  rw [h1, mul_eq_zero] at h,\n  cases h with hl hr,\n  { right,            -- The case `y = 0`.\n    show y = 0, from hl, }, \n  { left,             -- The case `x - 7 = 0`.\n    show x = 7,\n    linarith, },\nend\n\n\n\n\n/-\nAdapt the proof of the example above to find \\\\(a\\\\) and \\\\(b\\\\) such that if  \\\\(x ^ 2 - 3 x + 2 = 0,\\\\)\nthen \\\\(x = a\\\\) or \\\\(x = b.\\\\)\n-/\n\n\n/- Theorem : no-side-bar\nGiven \\\\(x ^ 2 - 3 x + 2 = 0,\\\\) there exist integers \\\\(a\\\\) and \\\\(b\\\\) sucht that \\\\(x = a\\\\)\nor \\\\(x = b.\\\\)\n-/\nexample (x : \u2124) (h : x ^ 2 - 3 * x + 2 = 0) : \u2203 a b, x = a \u2228 x = b :=\nbegin\n", "proof": "  have h1 : x ^ 2 - 3 * x + 2 = (x - 1) * (x - 2), ring,\n  rw h1 at h,\n  rw mul_eq_zero at h,\n  use [1, 2],\n  cases h,\n  { left, \n    linarith, },\n  { right,\n    linarith, },\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 12, "editorText": "sorry", "lineOffset": 87, "name": "", "statement": "(x : \u2124) (h : x ^ 2 - 3 * x + 2 = 0) : \u2203 a b, x = a \u2228 x = b"}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "222", "hidden": true}, {"type": "text", "content": "223"}, {"type": "text", "content": "224"}, {"type": "example", "text": "226", "lean": "example (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\n", "sideBar": false, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "import game.numbers.level8 -- hide\n\n/-\n## Level 9 : Simp and nested cases\n-/\n\n\n/-\nThe `simp` tactic is a turbo-charged version of `rw`. It will rewrite with the given\nlemmas and hypotheses multiple times until either it closes the goal or until\nit can make no further progress.\n\nIt also 'knows about' certain results and will use these automatically.\n\nIn the example below, we invoke `simp` with hypotheses `h1` and `h2`. But `simp` also\ncalls upon other resutlts including `zero_add` and `add_left_inj`. The benefit of `simp`\nis that you don't need to learn about these other results.\n-/\n\n/- Example : no-side-bar\nIf \\\\(a = b + c\\\\) and \\\\(b + c = 5,\\\\) then \\\\(0 + a + (b + c) ^ 2 = 5 + 5 ^ 2.\\\\)\n-/\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n", "proof": "  simp [h1, h2],", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n`simp` permits the use of `*` to refer to the set of all hypotheses. Thus the above proof could be\nwritten as follows.\n-/\n\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp *,\nend\n\n\n\n/- Tactic : simp\n## Summary\n`simp` performs targetted rewriting of either the target or a hypothesis (using `simp at h`).\n## Detail\nIt applies a set of rewrites in different orders and possibly multiple times until it can make\nno more progress.\n\nCertain Lean results are marked as 'simp lemmas'. These are automatically applied by `simp`.\nYou can specify other results for `simp` to use by enclosing them in brackets:\n```\nsimp [h1, h1, h3],\n```\n## Variations\nThe symbol `*` can be included among the list of lemmas provided to `simp`. This asks\n`simp` to use _all_ the hypotheses in the context. For example,\n`simp [zero_add, *]` asks `simp` to use the `zero_add` result and all hypotheses in the context.\n\nLikewise `simp at *` asks Lean to simplify at the target at at all hypotheses in the context.\n-/\n\n/-\nIn the proof below, we use nested cases. First we rewrite `h` and `k` with `mul_eq_zero` so\nthey become `h : x = 0 \u2228 y = 0` and `k : (x + y + 2 = 0) \u2228 (x + y + 3 = 0)`.\n\nThe outer `case` analyses the cases of `h`. Each inner case then analyses the cases of `k`.\n\nThe `at *` in our `simp` application means, 'simplify at the target and and every hypothesis'.\n-/\n\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) and \\\\((x + y + 2)(x + y + 3) = 0,\\\\) then\n\\\\((x + 2) (x + 3) (y + 2) (y + 3) = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) (k : (x + y + 2) * (x + y + 3) = 0) :\n(x + 2) * (x + 3) * (y + 2) * (y + 3) = 0 :=\nbegin\n  rw mul_eq_zero at h k,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { simp * at *, },\n    { simp * at *, }, },\n  { cases k with k1 k2,\n    { simp * at *,  },\n    { simp * at *}, },\nend\n\n/-\nFor the next problem, you'll need nested cases and a bit of ingenuity.\n-/\n\n/- Hint : Hint\nYou'll need to start by massaging the target into an appopriate form. The methods seen in earlier\nlevels will help you achieve this.\n-/\n\n/- Theorem : no-side-bar\nFor integers \\\\(x\\\\) and \\\\(y\\\\), given \\\\(x = 2 \\lor y = 3,\\\\) given\n\\\\(x + y = 0 \\lor x - y = 0,\\\\) we have that \\\\(x ^ 2 - y ^ 2 + x + y\\\\) is \\\\(2 + y\\\\)\nor \\\\(x + 3.\\\\)\n-/\nexample (x y : \u2124) (h : x = 2 \u2228 y = 3) (k : x + y = 0 \u2228 x - y = 0) :\n(x ^ 2 - y ^ 2 + x + y = 2 + y) \u2228 (x ^ 2 - y ^ 2 + x + y = x + 3) :=\nbegin\n  have p : x ^ 2 - y ^ 2 = (x - y) * (x + y), ring,\n  rw p,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { left,\n      simp * at *, },\n    { left,\n      simp * at *, }, },\n  { cases k with k1 k2,\n    { right,\n      simp * at *, },\n    { right,\n      simp * at *, }, },\n\n\n\nend\n\n\n\n\n\n", "height": 1, "editorText": "225", "lineOffset": 25, "statement": "(a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2"}, {"type": "text", "content": "227"}, {"type": "lean", "content": "228", "hidden": false}, {"type": "tactic", "content": "229", "name": "simp", "sideBar": true}, {"type": "text", "content": "230"}, {"type": "example", "text": "232", "lean": "example (x y : \u2124) (h : x * y = 0) (k : (x + y + 2) * (x + y + 3) = 0) :\n(x + 2) * (x + 3) * (y + 2) * (y + 3) = 0 :=\n", "sideBar": false, "firstProofLineNumber": 79, "lastProofLineNumber": 86, "textBefore": "import game.numbers.level8 -- hide\n\n/-\n## Level 9 : Simp and nested cases\n-/\n\n\n/-\nThe `simp` tactic is a turbo-charged version of `rw`. It will rewrite with the given\nlemmas and hypotheses multiple times until either it closes the goal or until\nit can make no further progress.\n\nIt also 'knows about' certain results and will use these automatically.\n\nIn the example below, we invoke `simp` with hypotheses `h1` and `h2`. But `simp` also\ncalls upon other resutlts including `zero_add` and `add_left_inj`. The benefit of `simp`\nis that you don't need to learn about these other results.\n-/\n\n/- Example : no-side-bar\nIf \\\\(a = b + c\\\\) and \\\\(b + c = 5,\\\\) then \\\\(0 + a + (b + c) ^ 2 = 5 + 5 ^ 2.\\\\)\n-/\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp [h1, h2],\nend\n\n/-\n`simp` permits the use of `*` to refer to the set of all hypotheses. Thus the above proof could be\nwritten as follows.\n-/\n\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp *,\nend\n\n\n\n/- Tactic : simp\n## Summary\n`simp` performs targetted rewriting of either the target or a hypothesis (using `simp at h`).\n## Detail\nIt applies a set of rewrites in different orders and possibly multiple times until it can make\nno more progress.\n\nCertain Lean results are marked as 'simp lemmas'. These are automatically applied by `simp`.\nYou can specify other results for `simp` to use by enclosing them in brackets:\n```\nsimp [h1, h1, h3],\n```\n## Variations\nThe symbol `*` can be included among the list of lemmas provided to `simp`. This asks\n`simp` to use _all_ the hypotheses in the context. For example,\n`simp [zero_add, *]` asks `simp` to use the `zero_add` result and all hypotheses in the context.\n\nLikewise `simp at *` asks Lean to simplify at the target at at all hypotheses in the context.\n-/\n\n/-\nIn the proof below, we use nested cases. First we rewrite `h` and `k` with `mul_eq_zero` so\nthey become `h : x = 0 \u2228 y = 0` and `k : (x + y + 2 = 0) \u2228 (x + y + 3 = 0)`.\n\nThe outer `case` analyses the cases of `h`. Each inner case then analyses the cases of `k`.\n\nThe `at *` in our `simp` application means, 'simplify at the target and and every hypothesis'.\n-/\n\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) and \\\\((x + y + 2)(x + y + 3) = 0,\\\\) then\n\\\\((x + 2) (x + 3) (y + 2) (y + 3) = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) (k : (x + y + 2) * (x + y + 3) = 0) :\n(x + 2) * (x + 3) * (y + 2) * (y + 3) = 0 :=\nbegin\n", "proof": "  rw mul_eq_zero at h k,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { simp * at *, },\n    { simp * at *, }, },\n  { cases k with k1 k2,\n    { simp * at *,  },\n    { simp * at *}, },", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nFor the next problem, you'll need nested cases and a bit of ingenuity.\n-/\n\n/- Hint : Hint\nYou'll need to start by massaging the target into an appopriate form. The methods seen in earlier\nlevels will help you achieve this.\n-/\n\n/- Theorem : no-side-bar\nFor integers \\\\(x\\\\) and \\\\(y\\\\), given \\\\(x = 2 \\lor y = 3,\\\\) given\n\\\\(x + y = 0 \\lor x - y = 0,\\\\) we have that \\\\(x ^ 2 - y ^ 2 + x + y\\\\) is \\\\(2 + y\\\\)\nor \\\\(x + 3.\\\\)\n-/\nexample (x y : \u2124) (h : x = 2 \u2228 y = 3) (k : x + y = 0 \u2228 x - y = 0) :\n(x ^ 2 - y ^ 2 + x + y = 2 + y) \u2228 (x ^ 2 - y ^ 2 + x + y = x + 3) :=\nbegin\n  have p : x ^ 2 - y ^ 2 = (x - y) * (x + y), ring,\n  rw p,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { left,\n      simp * at *, },\n    { left,\n      simp * at *, }, },\n  { cases k with k1 k2,\n    { right,\n      simp * at *, },\n    { right,\n      simp * at *, }, },\n\n\n\nend\n\n\n\n\n\n", "height": 8, "editorText": "231", "lineOffset": 78, "statement": "(x y : \u2124) (h : x * y = 0) (k : (x + y + 2) * (x + y + 3) = 0) :\n(x + 2) * (x + 3) * (y + 2) * (y + 3) = 0"}, {"type": "text", "content": "233"}, {"type": "hint", "content": "234", "title": "235"}, {"type": "theorem", "text": "236", "lean": "example (x y : \u2124) (h : x = 2 \u2228 y = 3) (k : x + y = 0 \u2228 x - y = 0) :\n(x ^ 2 - y ^ 2 + x + y = 2 + y) \u2228 (x ^ 2 - y ^ 2 + x + y = x + 3) :=\n", "sideBar": false, "firstProofLineNumber": 106, "lastProofLineNumber": 121, "textBefore": "import game.numbers.level8 -- hide\n\n/-\n## Level 9 : Simp and nested cases\n-/\n\n\n/-\nThe `simp` tactic is a turbo-charged version of `rw`. It will rewrite with the given\nlemmas and hypotheses multiple times until either it closes the goal or until\nit can make no further progress.\n\nIt also 'knows about' certain results and will use these automatically.\n\nIn the example below, we invoke `simp` with hypotheses `h1` and `h2`. But `simp` also\ncalls upon other resutlts including `zero_add` and `add_left_inj`. The benefit of `simp`\nis that you don't need to learn about these other results.\n-/\n\n/- Example : no-side-bar\nIf \\\\(a = b + c\\\\) and \\\\(b + c = 5,\\\\) then \\\\(0 + a + (b + c) ^ 2 = 5 + 5 ^ 2.\\\\)\n-/\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp [h1, h2],\nend\n\n/-\n`simp` permits the use of `*` to refer to the set of all hypotheses. Thus the above proof could be\nwritten as follows.\n-/\n\nexample (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp *,\nend\n\n\n\n/- Tactic : simp\n## Summary\n`simp` performs targetted rewriting of either the target or a hypothesis (using `simp at h`).\n## Detail\nIt applies a set of rewrites in different orders and possibly multiple times until it can make\nno more progress.\n\nCertain Lean results are marked as 'simp lemmas'. These are automatically applied by `simp`.\nYou can specify other results for `simp` to use by enclosing them in brackets:\n```\nsimp [h1, h1, h3],\n```\n## Variations\nThe symbol `*` can be included among the list of lemmas provided to `simp`. This asks\n`simp` to use _all_ the hypotheses in the context. For example,\n`simp [zero_add, *]` asks `simp` to use the `zero_add` result and all hypotheses in the context.\n\nLikewise `simp at *` asks Lean to simplify at the target at at all hypotheses in the context.\n-/\n\n/-\nIn the proof below, we use nested cases. First we rewrite `h` and `k` with `mul_eq_zero` so\nthey become `h : x = 0 \u2228 y = 0` and `k : (x + y + 2 = 0) \u2228 (x + y + 3 = 0)`.\n\nThe outer `case` analyses the cases of `h`. Each inner case then analyses the cases of `k`.\n\nThe `at *` in our `simp` application means, 'simplify at the target and and every hypothesis'.\n-/\n\n\n/- Example : no-side-bar\nIf  \\\\(xy = 0\\\\) and \\\\((x + y + 2)(x + y + 3) = 0,\\\\) then\n\\\\((x + 2) (x + 3) (y + 2) (y + 3) = 0.\\\\)\n-/\nexample (x y : \u2124) (h : x * y = 0) (k : (x + y + 2) * (x + y + 3) = 0) :\n(x + 2) * (x + 3) * (y + 2) * (y + 3) = 0 :=\nbegin\n  rw mul_eq_zero at h k,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { simp * at *, },\n    { simp * at *, }, },\n  { cases k with k1 k2,\n    { simp * at *,  },\n    { simp * at *}, },\nend\n\n/-\nFor the next problem, you'll need nested cases and a bit of ingenuity.\n-/\n\n/- Hint : Hint\nYou'll need to start by massaging the target into an appopriate form. The methods seen in earlier\nlevels will help you achieve this.\n-/\n\n/- Theorem : no-side-bar\nFor integers \\\\(x\\\\) and \\\\(y\\\\), given \\\\(x = 2 \\lor y = 3,\\\\) given\n\\\\(x + y = 0 \\lor x - y = 0,\\\\) we have that \\\\(x ^ 2 - y ^ 2 + x + y\\\\) is \\\\(2 + y\\\\)\nor \\\\(x + 3.\\\\)\n-/\nexample (x y : \u2124) (h : x = 2 \u2228 y = 3) (k : x + y = 0 \u2228 x - y = 0) :\n(x ^ 2 - y ^ 2 + x + y = 2 + y) \u2228 (x ^ 2 - y ^ 2 + x + y = x + 3) :=\nbegin\n", "proof": "  have p : x ^ 2 - y ^ 2 = (x - y) * (x + y), ring,\n  rw p,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { left,\n      simp * at *, },\n    { left,\n      simp * at *, }, },\n  { cases k with k1 k2,\n    { right,\n      simp * at *, },\n    { right,\n      simp * at *, }, },\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n\n\n", "height": 16, "editorText": "sorry", "lineOffset": 105, "name": "", "statement": "(x y : \u2124) (h : x = 2 \u2228 y = 3) (k : x + y = 0 \u2228 x - y = 0) :\n(x ^ 2 - y ^ 2 + x + y = 2 + y) \u2228 (x ^ 2 - y ^ 2 + x + y = x + 3)"}]}], "parents": [1]}, {"name": "237", "levels": [{"name": "", "problemIndex": 16, "objects": [{"type": "lean", "content": "238", "hidden": true}, {"type": "lean", "content": "239", "hidden": true}, {"type": "text", "content": "240"}, {"type": "text", "content": "241"}, {"type": "example", "text": "243", "lean": "example : 21 % 6 = 3 :=\n", "sideBar": false, "firstProofLineNumber": 20, "lastProofLineNumber": 20, "textBefore": "import game.numbers.level8 -- hide\n\nopen nat -- hide\n\n/-\n## Level 1 : Remainders\n-/\n\n/-\nIn Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe remainder on dividing 21 by 6 is 3.\n-/\nexample : 21 % 6 = 3 :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\nRemainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n-/\n\n/- Axiom : add_mod\n(a + b) % m = ((a % m) + (b % m)) % m\n-/\n\n/-\nWe use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n-/\n\n/- Example : no-side-bar\n\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n-/\nexample (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\nbegin\n  rw add_mod x y,\nend\n\n/-\nApplying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n-/\n\n/- Axiom : mod_mod\n(a % m) % m = a % m\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  rw [mod_mod, mod_mod, mod_mod],\nend\n\n/-\nIt's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  simp [mod_mod],\nend\n\n/-\nIn fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n-/\n\n\n/-\nTry proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n-/\n\n\n/- Theorem : no-side-bar\n\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n-/\nexample (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\nbegin\n  rw add_mod (x + y) z,\n  rw add_mod x y,\n  rw add_mod ((x % 10) + (y % 10)) _,\n  rw mod_mod,\n\n\n\nend\n", "height": 1, "editorText": "242", "lineOffset": 19, "statement": "21 % 6 = 3"}, {"type": "text", "content": "244"}, {"type": "axiom", "content": "245", "name": "add_mod", "sideBar": true}, {"type": "text", "content": "246"}, {"type": "example", "text": "248", "lean": "example (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 55, "textBefore": "import game.numbers.level8 -- hide\n\nopen nat -- hide\n\n/-\n## Level 1 : Remainders\n-/\n\n/-\nIn Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe remainder on dividing 21 by 6 is 3.\n-/\nexample : 21 % 6 = 3 :=\nbegin\n  refl,\nend\n\n\n/-\nRemainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n-/\n\n/- Axiom : add_mod\n(a + b) % m = ((a % m) + (b % m)) % m\n-/\n\n/-\nWe use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n-/\n\n/- Example : no-side-bar\n\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n-/\nexample (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\nbegin\n", "proof": "  rw add_mod x y,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nApplying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n-/\n\n/- Axiom : mod_mod\n(a % m) % m = a % m\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  rw [mod_mod, mod_mod, mod_mod],\nend\n\n/-\nIt's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  simp [mod_mod],\nend\n\n/-\nIn fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n-/\n\n\n/-\nTry proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n-/\n\n\n/- Theorem : no-side-bar\n\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n-/\nexample (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\nbegin\n  rw add_mod (x + y) z,\n  rw add_mod x y,\n  rw add_mod ((x % 10) + (y % 10)) _,\n  rw mod_mod,\n\n\n\nend\n", "height": 1, "editorText": "247", "lineOffset": 54, "statement": "(x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10"}, {"type": "text", "content": "249"}, {"type": "axiom", "content": "250", "name": "mod_mod", "sideBar": true}, {"type": "example", "text": "252", "lean": "example (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 73, "textBefore": "import game.numbers.level8 -- hide\n\nopen nat -- hide\n\n/-\n## Level 1 : Remainders\n-/\n\n/-\nIn Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe remainder on dividing 21 by 6 is 3.\n-/\nexample : 21 % 6 = 3 :=\nbegin\n  refl,\nend\n\n\n/-\nRemainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n-/\n\n/- Axiom : add_mod\n(a + b) % m = ((a % m) + (b % m)) % m\n-/\n\n/-\nWe use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n-/\n\n/- Example : no-side-bar\n\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n-/\nexample (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\nbegin\n  rw add_mod x y,\nend\n\n/-\nApplying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n-/\n\n/- Axiom : mod_mod\n(a % m) % m = a % m\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n", "proof": "  rw [mod_mod, mod_mod, mod_mod],", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nIt's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  simp [mod_mod],\nend\n\n/-\nIn fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n-/\n\n\n/-\nTry proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n-/\n\n\n/- Theorem : no-side-bar\n\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n-/\nexample (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\nbegin\n  rw add_mod (x + y) z,\n  rw add_mod x y,\n  rw add_mod ((x % 10) + (y % 10)) _,\n  rw mod_mod,\n\n\n\nend\n", "height": 1, "editorText": "251", "lineOffset": 72, "statement": "(x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10"}, {"type": "text", "content": "253"}, {"type": "example", "text": "255", "lean": "example (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\n", "sideBar": false, "firstProofLineNumber": 88, "lastProofLineNumber": 88, "textBefore": "import game.numbers.level8 -- hide\n\nopen nat -- hide\n\n/-\n## Level 1 : Remainders\n-/\n\n/-\nIn Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe remainder on dividing 21 by 6 is 3.\n-/\nexample : 21 % 6 = 3 :=\nbegin\n  refl,\nend\n\n\n/-\nRemainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n-/\n\n/- Axiom : add_mod\n(a + b) % m = ((a % m) + (b % m)) % m\n-/\n\n/-\nWe use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n-/\n\n/- Example : no-side-bar\n\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n-/\nexample (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\nbegin\n  rw add_mod x y,\nend\n\n/-\nApplying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n-/\n\n/- Axiom : mod_mod\n(a % m) % m = a % m\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  rw [mod_mod, mod_mod, mod_mod],\nend\n\n/-\nIt's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n", "proof": "  simp [mod_mod],", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nIn fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n-/\n\n\n/-\nTry proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n-/\n\n\n/- Theorem : no-side-bar\n\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n-/\nexample (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\nbegin\n  rw add_mod (x + y) z,\n  rw add_mod x y,\n  rw add_mod ((x % 10) + (y % 10)) _,\n  rw mod_mod,\n\n\n\nend\n", "height": 1, "editorText": "254", "lineOffset": 87, "statement": "(x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10"}, {"type": "text", "content": "256"}, {"type": "text", "content": "257"}, {"type": "theorem", "text": "258", "lean": "example (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\n", "sideBar": false, "firstProofLineNumber": 112, "lastProofLineNumber": 118, "textBefore": "import game.numbers.level8 -- hide\n\nopen nat -- hide\n\n/-\n## Level 1 : Remainders\n-/\n\n/-\nIn Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe remainder on dividing 21 by 6 is 3.\n-/\nexample : 21 % 6 = 3 :=\nbegin\n  refl,\nend\n\n\n/-\nRemainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n-/\n\n/- Axiom : add_mod\n(a + b) % m = ((a % m) + (b % m)) % m\n-/\n\n/-\nWe use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n-/\n\n/- Example : no-side-bar\n\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n-/\nexample (x y : \u2115) :\n(x + x) % 10 + (x + y) % 10 =\n  (x + x) % 10 + ((x % 10) + (y % 10)) % 10 :=\nbegin\n  rw add_mod x y,\nend\n\n/-\nApplying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n-/\n\n/- Axiom : mod_mod\n(a % m) % m = a % m\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  rw [mod_mod, mod_mod, mod_mod],\nend\n\n/-\nIt's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n-/\n\n/- Example : no-side-bar\nThe four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n-/\nexample (x : \u2115) : x % 10 % 10 % 10 % 10 = x % 10 :=\nbegin\n  simp [mod_mod],\nend\n\n/-\nIn fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n-/\n\n\n/-\nTry proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n-/\n\n\n/- Theorem : no-side-bar\n\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n-/\nexample (x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10 :=\nbegin\n", "proof": "  rw add_mod (x + y) z,\n  rw add_mod x y,\n  rw add_mod ((x % 10) + (y % 10)) _,\n  rw mod_mod,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 111, "name": "", "statement": "(x y z : \u2115) :\n(x + y + z) % 10 = ((x % 10) + (y % 10) + (z % 10)) % 10"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "259", "hidden": true}, {"type": "lean", "content": "260", "hidden": true}, {"type": "text", "content": "261"}, {"type": "text", "content": "262"}, {"type": "axiom", "content": "263", "name": "mul-mod", "sideBar": true}, {"type": "text", "content": "264"}, {"type": "example", "text": "266", "lean": "example (a : \u2115) (h : (a % 4 = 1) \u2228 (a % 4 = 3)) : (a * a) % 4 = 1 :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 37, "textBefore": "import game.remainders.level1 -- hide\n\nopen nat -- hide\n\n/-\n## Level 2 : Dealing with remainders by cases\n-/\n\n/-\nRemainders behave nicely with respect to multiplication.\n`mul_mod a b m` is the result that\n```\n(a * b) % m = ((a % m) * (b % m)) % m\n```\n-/\n\n/- Axiom : mul-mod\n(a * b) % m = ((a % m) * (b % m)) % m\n-/\n\n/-\nUsing this, we prove that \\\\(a ^ 2\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n\n-/\n\n/- Example : no-side-bar\n\\\\(a \\times a\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n-/\nexample (a : \u2115) (h : (a % 4 = 1) \u2228 (a % 4 = 3)) : (a * a) % 4 = 1 :=\nbegin\n", "proof": "  cases h with h1 h2,\n  { simp [mul_mod, h1], },\n  { -- `simpa` does a `simp` then tries to close \n    -- the goal with an assumption or reflexivity.\n    simpa [mul_mod, h2], }, ", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n/- Theorem : no-side-bar\nThere exists a natural number \\\\(n\\\\) such that for every natural number \\\\(a,\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(3\\\\) or \\\\(2\\\\) on division by \\\\(5\\\\), then \\\\(a \u00d7 a\\\\) leaves\nremainder \\\\(n\\\\) on division by \\\\(5.\\\\)\n-/\nexample :\n\u2203 (n : \u2115), \u2200 (a : \u2115), (a % 5 = 3) \u2228 (a % 5 = 2) \u2192 (a * a) % 5 = n :=\nbegin\n  use 4,\n  assume a : \u2115,\n  assume h : (a % 5 = 3) \u2228 (a % 5 = 2),\n  cases h with h1 h2,\n  { simpa [mul_mod, h1], },\n  { simpa [mul_mod, h2], }, \n\n\nend\n", "height": 5, "editorText": "265", "lineOffset": 32, "statement": "(a : \u2115) (h : (a % 4 = 1) \u2228 (a % 4 = 3)) : (a * a) % 4 = 1"}, {"type": "theorem", "text": "267", "lean": "example :\n\u2203 (n : \u2115), \u2200 (a : \u2115), (a % 5 = 3) \u2228 (a % 5 = 2) \u2192 (a * a) % 5 = n :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 57, "textBefore": "import game.remainders.level1 -- hide\n\nopen nat -- hide\n\n/-\n## Level 2 : Dealing with remainders by cases\n-/\n\n/-\nRemainders behave nicely with respect to multiplication.\n`mul_mod a b m` is the result that\n```\n(a * b) % m = ((a % m) * (b % m)) % m\n```\n-/\n\n/- Axiom : mul-mod\n(a * b) % m = ((a % m) * (b % m)) % m\n-/\n\n/-\nUsing this, we prove that \\\\(a ^ 2\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n\n-/\n\n/- Example : no-side-bar\n\\\\(a \\times a\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n-/\nexample (a : \u2115) (h : (a % 4 = 1) \u2228 (a % 4 = 3)) : (a * a) % 4 = 1 :=\nbegin\n  cases h with h1 h2,\n  { simp [mul_mod, h1], },\n  { -- `simpa` does a `simp` then tries to close \n    -- the goal with an assumption or reflexivity.\n    simpa [mul_mod, h2], }, \nend\n\n\n\n/- Theorem : no-side-bar\nThere exists a natural number \\\\(n\\\\) such that for every natural number \\\\(a,\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(3\\\\) or \\\\(2\\\\) on division by \\\\(5\\\\), then \\\\(a \u00d7 a\\\\) leaves\nremainder \\\\(n\\\\) on division by \\\\(5.\\\\)\n-/\nexample :\n\u2203 (n : \u2115), \u2200 (a : \u2115), (a % 5 = 3) \u2228 (a % 5 = 2) \u2192 (a * a) % 5 = n :=\nbegin\n", "proof": "  use 4,\n  assume a : \u2115,\n  assume h : (a % 5 = 3) \u2228 (a % 5 = 2),\n  cases h with h1 h2,\n  { simpa [mul_mod, h1], },\n  { simpa [mul_mod, h2], }, \n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 49, "name": "", "statement": "\u2203 (n : \u2115), \u2200 (a : \u2115), (a % 5 = 3) \u2228 (a % 5 = 2) \u2192 (a * a) % 5 = n"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "268", "hidden": true}, {"type": "lean", "content": "269", "hidden": true}, {"type": "text", "content": "270"}, {"type": "text", "content": "271"}, {"type": "hint", "content": "272", "title": "273"}, {"type": "theorem", "text": "274", "lean": "lemma mod3_eq_1_or_mod3_eq_2 {a b : \u2115}\n  (h : a % 3 = 1 \u2228 a % 3 = 2)\n  (k : b % 3 = a % 3 \u2228  b % 3 = (2 * a % 3)) :\n  b % 3 = 1 \u2228 b % 3 = 2 :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 44, "textBefore": "import game.remainders.level2 -- hide\n\nopen nat -- hide\n\n/-\n## Level 3 : A useful result\n-/\n\n/-\nThe following result will be useful in our study of the MIU system.\n-/\n\n/- Hint : Hint\nYou'll need to do a proof by nested cases. The `simp` tactic or its\n`simpa` variant will come in helpful, especially with `mul_mod`.\n-/\n\n/- Theorem : mod3_eq_1_or_mod3_eq_2\nLet \\\\(a\\\\) and \\\\(b\\\\) be natural numbers.\nGiven that \\\\(a \\mod 3\\\\) is \\\\(1\\\\) or \\\\(2\\\\),\ngiven that \\\\(b \\mod 3\\\\) is \\\\(a \\mod 3\\\\) or \\\\(2a \\mod 3,\\\\)\nwe have that \\\\(b \\mod 3\\\\) is \\\\(1\\\\) or \\\\(2\\\\).\n-/\nlemma mod3_eq_1_or_mod3_eq_2 {a b : \u2115}\n  (h : a % 3 = 1 \u2228 a % 3 = 2)\n  (k : b % 3 = a % 3 \u2228  b % 3 = (2 * a % 3)) :\n  b % 3 = 1 \u2228 b % 3 = 2 :=\nbegin\n", "proof": "  cases h with h1 h2,\n  { cases k with k1 k2,\n    { left,\n      rwa k1, },\n    { right,\n      simpa [k2, h1, mul_mod], }, },\n  { cases k with k1 k2,\n    { right,\n      rw [k1, h2], },\n    { left,\n      simpa [k2, h2, mul_mod], }, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 16, "editorText": "sorry", "lineOffset": 28, "name": "mod3_eq_1_or_mod3_eq_2", "statement": "{a b : \u2115}\n  (h : a % 3 = 1 \u2228 a % 3 = 2)\n  (k : b % 3 = a % 3 \u2228  b % 3 = (2 * a % 3)) :\n  b % 3 = 1 \u2228 b % 3 = 2"}]}], "parents": [2]}, {"name": "275", "levels": [{"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "276", "hidden": true}, {"type": "lean", "content": "277", "hidden": true}, {"type": "text", "content": "278"}, {"type": "text", "content": "279"}, {"type": "example", "text": "281", "lean": "example : derivable [M, I, I, I, I, U] :=\n", "sideBar": false, "firstProofLineNumber": 21, "lastProofLineNumber": 23, "textBefore": "import game.numbers.level8 -- hide\n\nopen letter -- hide\n\n/-\n## Level 1 : List notation\n-/\n\n/-\nUnder the hood, derivability in the MIU sytem is concerned not with\nstrings, but with lists of letters.\n\nFor example, the string `\"MIU\"` is interpreted as a list `[M, I, U]` of letters.\n-/\n\n/- Example : no-side-bar\nThe list `[M, I, I, I, I, U]` is derivable.\n-/\nexample : derivable [M, I, I, I, I, U] :=\nbegin\n", "proof": "  have h1 : derivable [M, I, I], from rule2 [I] der_MI,\n  have h2 : derivable [M, I, I, I, I], from rule2 [I, I] h1,\n  from rule1 [M, I, I, I] h2,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n**Caution**: the `use` tactic needs to be treated carefully when dealing with lists.\nIf you typed `use [I]` below, Lean would assume you were trying to use the letter `I` rather than\nthe list `[I]`.\n-/\n\n/- Example : no-side-bar\nThere is a list `a` such that `[M, U] ++ a` (i.e. `a` appended to `[M, U]`) is derivable.\n-/\nexample : \u2203 (a : list letter), derivable ([M, U] ++ a) :=\nbegin\n  use [[I]],\n  apply rule3 [M],\n  apply rule2 [I, I],\n  apply rule2 [I],\n  from der_MI,\nend\n\n/-\nNote that the empty (or nil) list is denoted `[]`.\n\nThe aim for the remainder of this world is to prove a couple of necessary conditions for a\nlist to be derivable in the MIU system. The conditions will concern the location(s) of the\nletter `M` in any derivable list.\n\nThe following problem has a one-line proof.\n-/\n\n\n/- Lemma : cons_M_MI\nThere is a list `ys` such that `[M, I] = M :: ys`.\nThat is, the base derivable string in the MIU system starts with a `M`.\n-/\nlemma cons_M_MI : \u2203 (ys : list letter), [M, I] = M :: ys :=\nbegin\n  use [[I]],\n\n\nend\n", "height": 3, "editorText": "280", "lineOffset": 20, "statement": "derivable [M, I, I, I, I, U]"}, {"type": "text", "content": "282"}, {"type": "example", "text": "284", "lean": "example : \u2203 (a : list letter), derivable ([M, U] ++ a) :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 41, "textBefore": "import game.numbers.level8 -- hide\n\nopen letter -- hide\n\n/-\n## Level 1 : List notation\n-/\n\n/-\nUnder the hood, derivability in the MIU sytem is concerned not with\nstrings, but with lists of letters.\n\nFor example, the string `\"MIU\"` is interpreted as a list `[M, I, U]` of letters.\n-/\n\n/- Example : no-side-bar\nThe list `[M, I, I, I, I, U]` is derivable.\n-/\nexample : derivable [M, I, I, I, I, U] :=\nbegin\n  have h1 : derivable [M, I, I], from rule2 [I] der_MI,\n  have h2 : derivable [M, I, I, I, I], from rule2 [I, I] h1,\n  from rule1 [M, I, I, I] h2,\nend\n\n/-\n**Caution**: the `use` tactic needs to be treated carefully when dealing with lists.\nIf you typed `use [I]` below, Lean would assume you were trying to use the letter `I` rather than\nthe list `[I]`.\n-/\n\n/- Example : no-side-bar\nThere is a list `a` such that `[M, U] ++ a` (i.e. `a` appended to `[M, U]`) is derivable.\n-/\nexample : \u2203 (a : list letter), derivable ([M, U] ++ a) :=\nbegin\n", "proof": "  use [[I]],\n  apply rule3 [M],\n  apply rule2 [I, I],\n  apply rule2 [I],\n  from der_MI,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nNote that the empty (or nil) list is denoted `[]`.\n\nThe aim for the remainder of this world is to prove a couple of necessary conditions for a\nlist to be derivable in the MIU system. The conditions will concern the location(s) of the\nletter `M` in any derivable list.\n\nThe following problem has a one-line proof.\n-/\n\n\n/- Lemma : cons_M_MI\nThere is a list `ys` such that `[M, I] = M :: ys`.\nThat is, the base derivable string in the MIU system starts with a `M`.\n-/\nlemma cons_M_MI : \u2203 (ys : list letter), [M, I] = M :: ys :=\nbegin\n  use [[I]],\n\n\nend\n", "height": 5, "editorText": "283", "lineOffset": 36, "statement": "\u2203 (a : list letter), derivable ([M, U] ++ a)"}, {"type": "text", "content": "285"}, {"type": "lemma", "text": "286", "lean": "lemma cons_M_MI : \u2203 (ys : list letter), [M, I] = M :: ys :=\n", "sideBar": true, "firstProofLineNumber": 61, "lastProofLineNumber": 63, "textBefore": "import game.numbers.level8 -- hide\n\nopen letter -- hide\n\n/-\n## Level 1 : List notation\n-/\n\n/-\nUnder the hood, derivability in the MIU sytem is concerned not with\nstrings, but with lists of letters.\n\nFor example, the string `\"MIU\"` is interpreted as a list `[M, I, U]` of letters.\n-/\n\n/- Example : no-side-bar\nThe list `[M, I, I, I, I, U]` is derivable.\n-/\nexample : derivable [M, I, I, I, I, U] :=\nbegin\n  have h1 : derivable [M, I, I], from rule2 [I] der_MI,\n  have h2 : derivable [M, I, I, I, I], from rule2 [I, I] h1,\n  from rule1 [M, I, I, I] h2,\nend\n\n/-\n**Caution**: the `use` tactic needs to be treated carefully when dealing with lists.\nIf you typed `use [I]` below, Lean would assume you were trying to use the letter `I` rather than\nthe list `[I]`.\n-/\n\n/- Example : no-side-bar\nThere is a list `a` such that `[M, U] ++ a` (i.e. `a` appended to `[M, U]`) is derivable.\n-/\nexample : \u2203 (a : list letter), derivable ([M, U] ++ a) :=\nbegin\n  use [[I]],\n  apply rule3 [M],\n  apply rule2 [I, I],\n  apply rule2 [I],\n  from der_MI,\nend\n\n/-\nNote that the empty (or nil) list is denoted `[]`.\n\nThe aim for the remainder of this world is to prove a couple of necessary conditions for a\nlist to be derivable in the MIU system. The conditions will concern the location(s) of the\nletter `M` in any derivable list.\n\nThe following problem has a one-line proof.\n-/\n\n\n/- Lemma : cons_M_MI\nThere is a list `ys` such that `[M, I] = M :: ys`.\nThat is, the base derivable string in the MIU system starts with a `M`.\n-/\nlemma cons_M_MI : \u2203 (ys : list letter), [M, I] = M :: ys :=\nbegin\n", "proof": "  use [[I]],\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 60, "name": "cons_M_MI", "statement": "\u2203 (ys : list letter), [M, I] = M :: ys"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "287", "hidden": true}, {"type": "lean", "content": "288", "hidden": true}, {"type": "text", "content": "289"}, {"type": "text", "content": "290"}, {"type": "lemma", "text": "291", "lean": "lemma cons_M_r2 {zs : list letter} :\n\u2203 (xs : list letter), (M :: zs) ++ zs = M :: xs :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 42, "textBefore": "import game.lists.level1 -- hide\n\nopen letter -- hide\n\n/-\n## Level 2 : Rule 2 and `M`\n-/\n\n/-\nIn the previous level, we showed that `[M, I]`, the base element of the MIU system,\nstarts with an `M`.\n\nMore precisely, when we say a list `ys` starts with an `M`, we mean that there exists a list `xs`\nsuch that `ys = M :: xs`.\n\n\nIn this level, we'll skip over rule 1 and show that if a string (i.e. list) in MIU is constructed\nvia rule 2, then it must also start with an `M`.\n\nRecall rule 2 states that if Mz is derivable, then so is Mzz. In our list language, a list\nderived by rule 2 must thus have the form `(M :: zs) ++ zs`, for some list `zs`.\n\nYour task is to prove that if a list has the form `(M :: zs) ++ zs`, then it starts with an `M`.\nThat is, there exists a list `xs` such that `(M :: zs) ++ zs = M :: xs`.\n\n**Note** the expression `(M :: zs) ++ zs` is not _syntactically_ the same as `M :: (zs ++ zs)`.\nHowever, the expressions are equal. This equality is known to the `simp` tactic.\n-/\n\n\n\n/- Lemma : cons_M_r2\nAny list constructed by rule 2 must start with the letter `M`.\n-/\nlemma cons_M_r2 {zs : list letter} :\n\u2203 (xs : list letter), (M :: zs) ++ zs = M :: xs :=\nbegin\n", "proof": "  use (zs ++ zs),\n  simp,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 37, "name": "cons_M_r2", "statement": "{zs : list letter} :\n\u2203 (xs : list letter), (M :: zs) ++ zs = M :: xs"}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "292", "hidden": true}, {"type": "lean", "content": "293", "hidden": true}, {"type": "text", "content": "294"}, {"type": "text", "content": "295"}, {"type": "example", "text": "297", "lean": "example : [I, M] = I :: M :: [] :=\n", "sideBar": false, "firstProofLineNumber": 27, "lastProofLineNumber": 27, "textBefore": "import game.lists.level2 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 3 : What is a list? Rule 1\n-/\n\n/-\nJust as derivability has a a base case and rules of production, so the _construction_ of a\nlist has two rules.\n\nA list is either:\n\n1. The nil list, `nil` (denoted `[]`) or\n2. `cons x xs` (denoted `x :: xs`) where `x` is a letter and `xs` is a list.\n\nA definition with a base case (or cases) and constructors that refer to already-constructed terms\nis called an _inductive defintion_.\n-/\n\n/- Example : no-side-bar\nConstructing a list with `::` and `[]`.\n-/\nexample : [I, M] = I :: M :: [] :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Example : no-side-bar\nConstructing a list with `cons` and `nil`.\n-/\nexample : [I, M] = cons I (cons M nil) :=\nbegin\n  refl,\nend\n\n\n\n/-\nFor the next problem, we continue looking at derivable strings (i.e. lists) in MIU.\nAny list constructed by rule 1 must take the form `zs ++ [I, U]` where\n`zs ++ [I]` is derivable.\n\nLet's _assume_ that the list `zs ++ [I]` starts with the letter `M`.\nThat is, assume `\u2203 (ys : list letter), zs + [I] = M :: ys`.\n\nWe'll prove that the list `zs ++ [I, U]` also starts with the letter `M`.\n-/\n\n\n/-\nWe record here a lemma that will be useful for this problem and other subsequent problems.\n-/\n\n/- Axiom : append_IU_eq_append_I_append_U\n\u2200 (xs : list letter), zs ++ [I, U] = (zs ++ [I]) ++ [U]\n-/\nlemma append_IU_eq_append_I_append_U (zs : list letter) :\nzs ++ [I, U] = (zs ++ [I]) ++ [U] :=\nbegin\n  simp,\nend\n\n\n\n\n/- Hint : Hint for dealing with hypothesis `h`\nRecall that an `\u2203` statement can be decomposed via the `cases` tactic. Start your proof with\n`cases h with ys hys`.\n-/\n\n/- Hint : Hint for using the decomposed hypothesis `h`\nIf you followed the previous hint, you'll be left with\n```\nhys : zs ++ [I] = M :: ys\n```\nBut your target will has the form\n```\n\u22a2 \u2203 ws, zs ++ [I, U] = M :: ws\n```\nThe left side of this expression doesn't exactly match the left side of `hys`.\nHowever, you can use `append_IU_eq_append_I_append_U` either via `rw` or `simp`.\n-/\n\n\n/- Lemma : cons_M_r1\nIf a list is constructed by rule 1 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r1 {zs : list letter}\n(h : \u2203 (ys : list letter), zs ++ [I] = M :: ys) :\n\u2203 (ws : list letter), zs ++ [I, U] = M :: ws :=\nbegin\n  cases h with ys hys,\n  use (ys ++ [U]),\n  simp [append_IU_eq_append_I_append_U, *] at *,\n\n\n\nend\n", "height": 1, "editorText": "296", "lineOffset": 26, "statement": "[I, M] = I :: M :: []"}, {"type": "example", "text": "299", "lean": "example : [I, M] = cons I (cons M nil) :=\n", "sideBar": false, "firstProofLineNumber": 35, "lastProofLineNumber": 35, "textBefore": "import game.lists.level2 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 3 : What is a list? Rule 1\n-/\n\n/-\nJust as derivability has a a base case and rules of production, so the _construction_ of a\nlist has two rules.\n\nA list is either:\n\n1. The nil list, `nil` (denoted `[]`) or\n2. `cons x xs` (denoted `x :: xs`) where `x` is a letter and `xs` is a list.\n\nA definition with a base case (or cases) and constructors that refer to already-constructed terms\nis called an _inductive defintion_.\n-/\n\n/- Example : no-side-bar\nConstructing a list with `::` and `[]`.\n-/\nexample : [I, M] = I :: M :: [] :=\nbegin\n  refl,\nend\n\n/- Example : no-side-bar\nConstructing a list with `cons` and `nil`.\n-/\nexample : [I, M] = cons I (cons M nil) :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n\n/-\nFor the next problem, we continue looking at derivable strings (i.e. lists) in MIU.\nAny list constructed by rule 1 must take the form `zs ++ [I, U]` where\n`zs ++ [I]` is derivable.\n\nLet's _assume_ that the list `zs ++ [I]` starts with the letter `M`.\nThat is, assume `\u2203 (ys : list letter), zs + [I] = M :: ys`.\n\nWe'll prove that the list `zs ++ [I, U]` also starts with the letter `M`.\n-/\n\n\n/-\nWe record here a lemma that will be useful for this problem and other subsequent problems.\n-/\n\n/- Axiom : append_IU_eq_append_I_append_U\n\u2200 (xs : list letter), zs ++ [I, U] = (zs ++ [I]) ++ [U]\n-/\nlemma append_IU_eq_append_I_append_U (zs : list letter) :\nzs ++ [I, U] = (zs ++ [I]) ++ [U] :=\nbegin\n  simp,\nend\n\n\n\n\n/- Hint : Hint for dealing with hypothesis `h`\nRecall that an `\u2203` statement can be decomposed via the `cases` tactic. Start your proof with\n`cases h with ys hys`.\n-/\n\n/- Hint : Hint for using the decomposed hypothesis `h`\nIf you followed the previous hint, you'll be left with\n```\nhys : zs ++ [I] = M :: ys\n```\nBut your target will has the form\n```\n\u22a2 \u2203 ws, zs ++ [I, U] = M :: ws\n```\nThe left side of this expression doesn't exactly match the left side of `hys`.\nHowever, you can use `append_IU_eq_append_I_append_U` either via `rw` or `simp`.\n-/\n\n\n/- Lemma : cons_M_r1\nIf a list is constructed by rule 1 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r1 {zs : list letter}\n(h : \u2203 (ys : list letter), zs ++ [I] = M :: ys) :\n\u2203 (ws : list letter), zs ++ [I, U] = M :: ws :=\nbegin\n  cases h with ys hys,\n  use (ys ++ [U]),\n  simp [append_IU_eq_append_I_append_U, *] at *,\n\n\n\nend\n", "height": 1, "editorText": "298", "lineOffset": 34, "statement": "[I, M] = cons I (cons M nil)"}, {"type": "text", "content": "300"}, {"type": "text", "content": "301"}, {"type": "axiom", "content": "302", "name": "append_IU_eq_append_I_append_U", "sideBar": true}, {"type": "lean", "content": "303", "hidden": false}, {"type": "hint", "content": "304", "title": "305"}, {"type": "hint", "content": "306", "title": "307"}, {"type": "lemma", "text": "308", "lean": "lemma cons_M_r1 {zs : list letter}\n(h : \u2203 (ys : list letter), zs ++ [I] = M :: ys) :\n\u2203 (ws : list letter), zs ++ [I, U] = M :: ws :=\n", "sideBar": true, "firstProofLineNumber": 95, "lastProofLineNumber": 100, "textBefore": "import game.lists.level2 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 3 : What is a list? Rule 1\n-/\n\n/-\nJust as derivability has a a base case and rules of production, so the _construction_ of a\nlist has two rules.\n\nA list is either:\n\n1. The nil list, `nil` (denoted `[]`) or\n2. `cons x xs` (denoted `x :: xs`) where `x` is a letter and `xs` is a list.\n\nA definition with a base case (or cases) and constructors that refer to already-constructed terms\nis called an _inductive defintion_.\n-/\n\n/- Example : no-side-bar\nConstructing a list with `::` and `[]`.\n-/\nexample : [I, M] = I :: M :: [] :=\nbegin\n  refl,\nend\n\n/- Example : no-side-bar\nConstructing a list with `cons` and `nil`.\n-/\nexample : [I, M] = cons I (cons M nil) :=\nbegin\n  refl,\nend\n\n\n\n/-\nFor the next problem, we continue looking at derivable strings (i.e. lists) in MIU.\nAny list constructed by rule 1 must take the form `zs ++ [I, U]` where\n`zs ++ [I]` is derivable.\n\nLet's _assume_ that the list `zs ++ [I]` starts with the letter `M`.\nThat is, assume `\u2203 (ys : list letter), zs + [I] = M :: ys`.\n\nWe'll prove that the list `zs ++ [I, U]` also starts with the letter `M`.\n-/\n\n\n/-\nWe record here a lemma that will be useful for this problem and other subsequent problems.\n-/\n\n/- Axiom : append_IU_eq_append_I_append_U\n\u2200 (xs : list letter), zs ++ [I, U] = (zs ++ [I]) ++ [U]\n-/\nlemma append_IU_eq_append_I_append_U (zs : list letter) :\nzs ++ [I, U] = (zs ++ [I]) ++ [U] :=\nbegin\n  simp,\nend\n\n\n\n\n/- Hint : Hint for dealing with hypothesis `h`\nRecall that an `\u2203` statement can be decomposed via the `cases` tactic. Start your proof with\n`cases h with ys hys`.\n-/\n\n/- Hint : Hint for using the decomposed hypothesis `h`\nIf you followed the previous hint, you'll be left with\n```\nhys : zs ++ [I] = M :: ys\n```\nBut your target will has the form\n```\n\u22a2 \u2203 ws, zs ++ [I, U] = M :: ws\n```\nThe left side of this expression doesn't exactly match the left side of `hys`.\nHowever, you can use `append_IU_eq_append_I_append_U` either via `rw` or `simp`.\n-/\n\n\n/- Lemma : cons_M_r1\nIf a list is constructed by rule 1 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r1 {zs : list letter}\n(h : \u2203 (ys : list letter), zs ++ [I] = M :: ys) :\n\u2203 (ws : list letter), zs ++ [I, U] = M :: ws :=\nbegin\n", "proof": "  cases h with ys hys,\n  use (ys ++ [U]),\n  simp [append_IU_eq_append_I_append_U, *] at *,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 6, "editorText": "sorry", "lineOffset": 94, "name": "cons_M_r1", "statement": "{zs : list letter}\n(h : \u2203 (ys : list letter), zs ++ [I] = M :: ys) :\n\u2203 (ws : list letter), zs ++ [I, U] = M :: ws"}]}, {"name": "", "problemIndex": 14, "objects": [{"type": "lean", "content": "309", "hidden": true}, {"type": "lean", "content": "310", "hidden": true}, {"type": "text", "content": "311"}, {"type": "text", "content": "312"}, {"type": "text", "content": "313"}, {"type": "lean", "content": "314", "hidden": false}, {"type": "example", "text": "316", "lean": "example : noggin [M, I, U] = M :=\n", "sideBar": false, "firstProofLineNumber": 38, "lastProofLineNumber": 38, "textBefore": "import game.lists.level3 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 4 : Functions on lists and proof by cases\n-/\n\n/-\nAs we saw in a previous level, lists have an inductive definition. A list is either `[]` or `x :: xs`\nfor a letter `x` and a list `xs`.\n\nThus, to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n-/\n\n/-\nFor the most simple kind of function, the value of `f(xs)` is not used in constructing `f(x :: xs)`.\n\nWe define a function `noggin` such that `noggin [] = U` and `noggin (x :: xs) = x`.\nThere's nothing special about `U` here, but we have to give _some_ value to `noggin []`. I've\njust chosen `U`.\n-/\n\ndef noggin : list letter \u2192 letter\n| []          := U\n| (x :: xs)   := x\n\n/- We can prove some concrete `noggin` results through reflexivity. -/\n\n/- Example : no-side-bar\nThe `noggin` of `[M, I, U]` is `M`.\n-/\nexample : noggin [M, I, U] = M :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nOf course, `noggin ys` can be thought of as 'the first letter' of `ys`. This only makes sense if\n`ys` is not the nil list.\n-/\n\n\n/-\nEarlier, we said that for a list `ys` to start with `M` means that there exists `xs` such that\n`ys = M :: xs`. It would be nice for this notion to imply that `noggin ys = M`.\n\nIndeed, we can prove such a result. We decompose `ys` into two possibilities.\n\n1. `ys` is the nil list, `[]` or\n2. `ys` is `p :: ps`, for some letter `p` and some list `ps`.\n\nWe're assuming `h : \u2203 xs, ys = M :: xs`.\n\nIn case 1., `h` becomes `h : \u2203 xs, [] = M :: xs`. This is clearly nonsense. We close this\ngoal using `simp * at *`.\n\nIn case 2., `h` becomes `h : \u2203 xs, (p :: ps) = M :: xs`. We start by decomposing `h` by cases\ninto the list `zs` and the hypothesis `hzs : (p :: ps) = M :: zs`. The goal is closed via\n`simp [*, noggin] at *`.\n-/\n\n/-\nIn Lean, the `cases` tactic performs this decomposition of `ys`. In principle, it's exactly the\nsame as decomposing an or statement `k : p \u2228 q` into a left part and right part.\n\nThe difference is that we need to label the variables that arise in the `cons` case. For example,\n`cases ys with p ps` means that the `cons` case should treat `ys` as `p :: ps`.\n\nWe use the `show` tactic below to help the reader understand what's happening in the `cons` case.\nIt isn't necessary for Lean.\n-/\n\n/- Example : no-side-bar\nGiven a list `ys`, if `\u2203 xs, ys = M :: xs`, then `noggin ys = M`.\n-/\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys with p ps, -- In the `cons` case, `ys = p :: ps`.\n  { simp * at *, },             -- The `nil` case\n  { show noggin (p :: ps) = M,  -- The `cons` case.\n    cases h with zs hzs, \n    simp [*, noggin] at *, },\nend\n\n/-\nLean offers an alternative format wherein each case is labelled with the constructor and any\nnecessary variables. We do this with the `case` tactic, as exemplified below.\n\n-/\n\n\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys,\n  case nil :          -- The `nil` case.\n  { simp * at *, },\n  case cons : p ps    -- The `cons` case.\n  { show noggin (p :: ps) = M,\n    cases h with zs hzs,\n    simp [*, noggin] at *, },\nend\n\n\n/-\nUsing the `cases` tactic, prove that if a list is constructed via rule 3 from a list that\nstarts with the letter `M`, then the constructed list also starts with the letter `M`.\n-/\n\n\n/- Theorem : cons_M_r3\nIf a list is constructed by rule 3 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r3 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [I, I, I]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ (U :: ws) = M :: xs :=\nbegin\n  cases h with ys hys,\n  cases zs,\n  case nil :\n  { show \u2203 (xs : list letter), nil ++ (U :: ws) = M :: xs,\n    simp * at *, },\n  case cons : p ps\n  { show \u2203 (xs : list letter), (p :: ps) ++ (U :: ws) = M :: xs,\n    use ps ++ U :: ws,\n    simp * at *, }\n\n\n\n\n\nend", "height": 1, "editorText": "315", "lineOffset": 37, "statement": "noggin [M, I, U] = M"}, {"type": "text", "content": "317"}, {"type": "text", "content": "318"}, {"type": "text", "content": "319"}, {"type": "example", "text": "321", "lean": "example {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\n", "sideBar": false, "firstProofLineNumber": 83, "lastProofLineNumber": 87, "textBefore": "import game.lists.level3 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 4 : Functions on lists and proof by cases\n-/\n\n/-\nAs we saw in a previous level, lists have an inductive definition. A list is either `[]` or `x :: xs`\nfor a letter `x` and a list `xs`.\n\nThus, to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n-/\n\n/-\nFor the most simple kind of function, the value of `f(xs)` is not used in constructing `f(x :: xs)`.\n\nWe define a function `noggin` such that `noggin [] = U` and `noggin (x :: xs) = x`.\nThere's nothing special about `U` here, but we have to give _some_ value to `noggin []`. I've\njust chosen `U`.\n-/\n\ndef noggin : list letter \u2192 letter\n| []          := U\n| (x :: xs)   := x\n\n/- We can prove some concrete `noggin` results through reflexivity. -/\n\n/- Example : no-side-bar\nThe `noggin` of `[M, I, U]` is `M`.\n-/\nexample : noggin [M, I, U] = M :=\nbegin\n  refl,\nend\n\n/-\nOf course, `noggin ys` can be thought of as 'the first letter' of `ys`. This only makes sense if\n`ys` is not the nil list.\n-/\n\n\n/-\nEarlier, we said that for a list `ys` to start with `M` means that there exists `xs` such that\n`ys = M :: xs`. It would be nice for this notion to imply that `noggin ys = M`.\n\nIndeed, we can prove such a result. We decompose `ys` into two possibilities.\n\n1. `ys` is the nil list, `[]` or\n2. `ys` is `p :: ps`, for some letter `p` and some list `ps`.\n\nWe're assuming `h : \u2203 xs, ys = M :: xs`.\n\nIn case 1., `h` becomes `h : \u2203 xs, [] = M :: xs`. This is clearly nonsense. We close this\ngoal using `simp * at *`.\n\nIn case 2., `h` becomes `h : \u2203 xs, (p :: ps) = M :: xs`. We start by decomposing `h` by cases\ninto the list `zs` and the hypothesis `hzs : (p :: ps) = M :: zs`. The goal is closed via\n`simp [*, noggin] at *`.\n-/\n\n/-\nIn Lean, the `cases` tactic performs this decomposition of `ys`. In principle, it's exactly the\nsame as decomposing an or statement `k : p \u2228 q` into a left part and right part.\n\nThe difference is that we need to label the variables that arise in the `cons` case. For example,\n`cases ys with p ps` means that the `cons` case should treat `ys` as `p :: ps`.\n\nWe use the `show` tactic below to help the reader understand what's happening in the `cons` case.\nIt isn't necessary for Lean.\n-/\n\n/- Example : no-side-bar\nGiven a list `ys`, if `\u2203 xs, ys = M :: xs`, then `noggin ys = M`.\n-/\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n", "proof": "  cases ys with p ps, -- In the `cons` case, `ys = p :: ps`.\n  { simp * at *, },             -- The `nil` case\n  { show noggin (p :: ps) = M,  -- The `cons` case.\n    cases h with zs hzs, \n    simp [*, noggin] at *, },", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nLean offers an alternative format wherein each case is labelled with the constructor and any\nnecessary variables. We do this with the `case` tactic, as exemplified below.\n\n-/\n\n\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys,\n  case nil :          -- The `nil` case.\n  { simp * at *, },\n  case cons : p ps    -- The `cons` case.\n  { show noggin (p :: ps) = M,\n    cases h with zs hzs,\n    simp [*, noggin] at *, },\nend\n\n\n/-\nUsing the `cases` tactic, prove that if a list is constructed via rule 3 from a list that\nstarts with the letter `M`, then the constructed list also starts with the letter `M`.\n-/\n\n\n/- Theorem : cons_M_r3\nIf a list is constructed by rule 3 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r3 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [I, I, I]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ (U :: ws) = M :: xs :=\nbegin\n  cases h with ys hys,\n  cases zs,\n  case nil :\n  { show \u2203 (xs : list letter), nil ++ (U :: ws) = M :: xs,\n    simp * at *, },\n  case cons : p ps\n  { show \u2203 (xs : list letter), (p :: ps) ++ (U :: ws) = M :: xs,\n    use ps ++ U :: ws,\n    simp * at *, }\n\n\n\n\n\nend", "height": 5, "editorText": "320", "lineOffset": 82, "statement": "{ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M"}, {"type": "text", "content": "322"}, {"type": "lean", "content": "323", "hidden": false}, {"type": "text", "content": "324"}, {"type": "theorem", "text": "325", "lean": "lemma cons_M_r3 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [I, I, I]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ (U :: ws) = M :: xs :=\n", "sideBar": true, "firstProofLineNumber": 124, "lastProofLineNumber": 137, "textBefore": "import game.lists.level3 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 4 : Functions on lists and proof by cases\n-/\n\n/-\nAs we saw in a previous level, lists have an inductive definition. A list is either `[]` or `x :: xs`\nfor a letter `x` and a list `xs`.\n\nThus, to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n-/\n\n/-\nFor the most simple kind of function, the value of `f(xs)` is not used in constructing `f(x :: xs)`.\n\nWe define a function `noggin` such that `noggin [] = U` and `noggin (x :: xs) = x`.\nThere's nothing special about `U` here, but we have to give _some_ value to `noggin []`. I've\njust chosen `U`.\n-/\n\ndef noggin : list letter \u2192 letter\n| []          := U\n| (x :: xs)   := x\n\n/- We can prove some concrete `noggin` results through reflexivity. -/\n\n/- Example : no-side-bar\nThe `noggin` of `[M, I, U]` is `M`.\n-/\nexample : noggin [M, I, U] = M :=\nbegin\n  refl,\nend\n\n/-\nOf course, `noggin ys` can be thought of as 'the first letter' of `ys`. This only makes sense if\n`ys` is not the nil list.\n-/\n\n\n/-\nEarlier, we said that for a list `ys` to start with `M` means that there exists `xs` such that\n`ys = M :: xs`. It would be nice for this notion to imply that `noggin ys = M`.\n\nIndeed, we can prove such a result. We decompose `ys` into two possibilities.\n\n1. `ys` is the nil list, `[]` or\n2. `ys` is `p :: ps`, for some letter `p` and some list `ps`.\n\nWe're assuming `h : \u2203 xs, ys = M :: xs`.\n\nIn case 1., `h` becomes `h : \u2203 xs, [] = M :: xs`. This is clearly nonsense. We close this\ngoal using `simp * at *`.\n\nIn case 2., `h` becomes `h : \u2203 xs, (p :: ps) = M :: xs`. We start by decomposing `h` by cases\ninto the list `zs` and the hypothesis `hzs : (p :: ps) = M :: zs`. The goal is closed via\n`simp [*, noggin] at *`.\n-/\n\n/-\nIn Lean, the `cases` tactic performs this decomposition of `ys`. In principle, it's exactly the\nsame as decomposing an or statement `k : p \u2228 q` into a left part and right part.\n\nThe difference is that we need to label the variables that arise in the `cons` case. For example,\n`cases ys with p ps` means that the `cons` case should treat `ys` as `p :: ps`.\n\nWe use the `show` tactic below to help the reader understand what's happening in the `cons` case.\nIt isn't necessary for Lean.\n-/\n\n/- Example : no-side-bar\nGiven a list `ys`, if `\u2203 xs, ys = M :: xs`, then `noggin ys = M`.\n-/\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys with p ps, -- In the `cons` case, `ys = p :: ps`.\n  { simp * at *, },             -- The `nil` case\n  { show noggin (p :: ps) = M,  -- The `cons` case.\n    cases h with zs hzs, \n    simp [*, noggin] at *, },\nend\n\n/-\nLean offers an alternative format wherein each case is labelled with the constructor and any\nnecessary variables. We do this with the `case` tactic, as exemplified below.\n\n-/\n\n\nexample {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys,\n  case nil :          -- The `nil` case.\n  { simp * at *, },\n  case cons : p ps    -- The `cons` case.\n  { show noggin (p :: ps) = M,\n    cases h with zs hzs,\n    simp [*, noggin] at *, },\nend\n\n\n/-\nUsing the `cases` tactic, prove that if a list is constructed via rule 3 from a list that\nstarts with the letter `M`, then the constructed list also starts with the letter `M`.\n-/\n\n\n/- Theorem : cons_M_r3\nIf a list is constructed by rule 3 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r3 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [I, I, I]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ (U :: ws) = M :: xs :=\nbegin\n", "proof": "  cases h with ys hys,\n  cases zs,\n  case nil :\n  { show \u2203 (xs : list letter), nil ++ (U :: ws) = M :: xs,\n    simp * at *, },\n  case cons : p ps\n  { show \u2203 (xs : list letter), (p :: ps) ++ (U :: ws) = M :: xs,\n    use ps ++ U :: ws,\n    simp * at *, }\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 14, "editorText": "sorry", "lineOffset": 123, "name": "cons_M_r3", "statement": "{zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [I, I, I]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ (U :: ws) = M :: xs"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "326", "hidden": true}, {"type": "lean", "content": "327", "hidden": true}, {"type": "text", "content": "328"}, {"type": "text", "content": "329"}, {"type": "theorem", "text": "330", "lean": "lemma cons_M_r4 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [U, U]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ ws = M :: xs :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 37, "textBefore": "import game.lists.level4 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 5 : Rule 4\n-/\n\n/-\nYour task in this level is to prove that f is a list is constructed by rule 4 from a list that starts\nwith the letter `M`, then the constructed list also starts with the letter `M`.\n-/\n\n\n\n/- Theorem : cons_M_r4\nIf a list is constructed by rule 4 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n-/\nlemma cons_M_r4 {zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [U, U]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ ws = M :: xs :=\nbegin\n", "proof": "  cases h with ys hys,\n  cases zs,\n  case nil :\n  { show \u2203 (xs : list letter), nil ++ ws = M :: xs,\n    simp * at *, },\n  case cons : p ps\n  { show \u2203 (xs : list letter), (p :: ps) ++ ws = M :: xs,\n    use (ps ++ ws),\n    simp * at *, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 14, "editorText": "sorry", "lineOffset": 23, "name": "cons_M_r4", "statement": "{zs ws : list letter}\n(h : \u2203 (ys : list letter), (zs ++ [U, U]) ++ ws = M :: ys) :\n\u2203 (xs : list letter), zs ++ ws = M :: xs"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "331", "hidden": true}, {"type": "lean", "content": "332", "hidden": true}, {"type": "text", "content": "333"}, {"type": "text", "content": "334"}, {"type": "text", "content": "335"}, {"type": "lean", "content": "336", "hidden": false}, {"type": "example", "text": "338", "lean": "example : \u2203 (a : list letter), interleave M [U, I, I] = a :=\n", "sideBar": false, "firstProofLineNumber": 40, "lastProofLineNumber": 42, "textBefore": "import game.lists.level5 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 6 : Recursive functions on lists\n-/\n\n/-\nPreviously, we saw that to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n-/\n\n/-\nIn our example `noggin`, the definition of `noggin (x :: xs)` did not depend on `noggin xs`. Things\nare more interesting when there is such a dependence.\n\n\nThe function `interleave` is defined so that if `y`\nis a letter, then\n\n1. `interleave y [] = []` and\n2. `interleave y (x :: xs) = x :: (y :: (interleave y xs))`, for any letter `x` and any list `xs`.\n\nInformally, its action is to pull out the first letter of a list, add in the given letter `y`,\nthen repeat the process. Thus the letter `y` is interleaved with the letters of the original list.\n-/\n\ndef interleave : letter \u2192 list letter \u2192 list letter\n| y []        := []\n| y (x :: xs) := x :: (y :: (interleave y xs))\n\n/- Example : no-side-bar\nWe find `a`, the result of interleaving `M` with `[U, I, I]`.\n-/\nexample : \u2203 (a : list letter), interleave M [U, I, I] = a :=\nbegin\n", "proof": "  -- The extra `[ ... ]` are needed due to the use of list notation.\n  use [ [U, M, I, M, I, M]  ],\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nThe problem for this level is for you to understand the mysterious function `mystery`.\n-/\n\ndef mystery : list letter \u2192 \u2115\n| []        := 0\n| (x :: xs) := (mystery xs) + 1\n\n\n/-\nFind the value of the natural number `a` below.\n-/\n\n\n/- Theorem : no-side-bar\nThere is a natural number `a` such that `mystery [U, I, M] = a`.\n-/\nexample : \u2203 (n : \u2115),  mystery [U, I, M] = n :=\nbegin\n  use 3,\n  refl,\n\n\nend\n", "height": 3, "editorText": "337", "lineOffset": 39, "statement": "\u2203 (a : list letter), interleave M [U, I, I] = a"}, {"type": "text", "content": "339"}, {"type": "lean", "content": "340", "hidden": false}, {"type": "text", "content": "341"}, {"type": "theorem", "text": "342", "lean": "example : \u2203 (n : \u2115),  mystery [U, I, M] = n :=\n", "sideBar": false, "firstProofLineNumber": 64, "lastProofLineNumber": 67, "textBefore": "import game.lists.level5 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 6 : Recursive functions on lists\n-/\n\n/-\nPreviously, we saw that to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n-/\n\n/-\nIn our example `noggin`, the definition of `noggin (x :: xs)` did not depend on `noggin xs`. Things\nare more interesting when there is such a dependence.\n\n\nThe function `interleave` is defined so that if `y`\nis a letter, then\n\n1. `interleave y [] = []` and\n2. `interleave y (x :: xs) = x :: (y :: (interleave y xs))`, for any letter `x` and any list `xs`.\n\nInformally, its action is to pull out the first letter of a list, add in the given letter `y`,\nthen repeat the process. Thus the letter `y` is interleaved with the letters of the original list.\n-/\n\ndef interleave : letter \u2192 list letter \u2192 list letter\n| y []        := []\n| y (x :: xs) := x :: (y :: (interleave y xs))\n\n/- Example : no-side-bar\nWe find `a`, the result of interleaving `M` with `[U, I, I]`.\n-/\nexample : \u2203 (a : list letter), interleave M [U, I, I] = a :=\nbegin\n  -- The extra `[ ... ]` are needed due to the use of list notation.\n  use [ [U, M, I, M, I, M]  ],\n  refl,\nend\n\n/-\nThe problem for this level is for you to understand the mysterious function `mystery`.\n-/\n\ndef mystery : list letter \u2192 \u2115\n| []        := 0\n| (x :: xs) := (mystery xs) + 1\n\n\n/-\nFind the value of the natural number `a` below.\n-/\n\n\n/- Theorem : no-side-bar\nThere is a natural number `a` such that `mystery [U, I, M] = a`.\n-/\nexample : \u2203 (n : \u2115),  mystery [U, I, M] = n :=\nbegin\n", "proof": "  use 3,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 4, "editorText": "sorry", "lineOffset": 63, "name": "", "statement": "\u2203 (n : \u2115),  mystery [U, I, M] = n"}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "343", "hidden": true}, {"type": "lean", "content": "344", "hidden": true}, {"type": "text", "content": "345"}, {"type": "text", "content": "346"}, {"type": "text", "content": "347"}, {"type": "example", "text": "349", "lean": "example (x : letter) (ys : list letter) : mystery(ys ++ [x]) = mystery(ys) + 1 :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 56, "textBefore": "import game.lists.level6 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 7 : Structural induction on lists\n-/\n\n/-\nIn a previous level, we show that if a list `ys` has the property that there exists a list `xs`\nfor which `ys = M :: xs`, then `noggin ys = M`.\n\nWe proved this by decomposing `ys` into cases, via the `cases` tactic. This sufficed because the\ndefinition of `noggin` is not truly recursive. That is, `noggin (x :: xs)` does not explicitly\ndepend on `noggin xs`.\n\nIn general, proving results that involve a recursive function requires a more sophisticated\nprinciple called _structural induction_ (or sometimes just _induction_). This is a generalisation\nof the induction principle for natural numbers that you may have seen at school.\n\nStructural induction on lists involves proving two things.\n\n1. Prove the result holds for the nil list.\n2. _Assuming_ that the result hold for a given list `xs`, prove that for every letter `x`, the\nresult holds for the list `x :: xs`.\n\nIn a proof by induction, 1. is called the base case and 2. is called the inductive step.\n-/\n\n/-\nAs a first example, we prove `mystery(ys ++ [x]) = mystery(ys) + 1`, for every letter `x` and\nevery list `ys`.\n\nWe do this by induction on `ys`.\n\n1. The base case is when `ys` is the nil list. We must prove `mystery (nil ++ [x]) = mystery nil + 1`.\n2. For the inductive step, `ys` is `z :: zs` for a letter `z` and a list `zs`.\nWe assume `ih : mystery (zs ++ [x]) = mystery zs + `. This is called the induction hypothesis.\nWe must prove `mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1.`\n\nI've used the `show` tactic in the proof below to indicate the targets of the base case and the\ninductive step. You don't need to do this, but it is recommended for clarity.\n-/\n\n/- Example : no-side-bar\nFor every letter `x` and every list `ys`, we have `mystery(ys ++ [x]) = mystery(ys) + 1`.\n-/\nexample (x : letter) (ys : list letter) : mystery(ys ++ [x]) = mystery(ys) + 1 :=\nbegin\n", "proof": "  induction ys, -- Proof by induction, analysing the variable ys.\n  case nil :            -- The base case.\n  { show mystery (nil ++ [x]) = mystery nil + 1,    \n    simp [mystery] },               \n  case cons : z zs ih   -- The inductive step.\n  { show mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1,\n    simp [mystery, ih], }, ", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Hint\nTry induction on `xs`.\n-/\n\n\n/- Theorem : no-side-bar\nFor all lists `xs` and `ys`, we have `mystery(xs ++ ys) = mystery xs + mystery ys`\n-/\nexample (xs ys) : mystery(xs ++ ys) = mystery xs + mystery ys :=\nbegin\n  induction xs,\n  case nil :\n  { show mystery (nil ++ ys) = mystery nil + mystery ys,\n    simp [mystery], },\n  case cons : z zs ih\n  { show mystery (z :: zs ++ ys) = mystery (z :: zs) + mystery ys,\n    simp [mystery, ih, add_right_comm], },\n\n\n\nend", "height": 7, "editorText": "348", "lineOffset": 49, "statement": "(x : letter) (ys : list letter) : mystery(ys ++ [x]) = mystery(ys) + 1"}, {"type": "hint", "content": "350", "title": "351"}, {"type": "theorem", "text": "352", "lean": "example (xs ys) : mystery(xs ++ ys) = mystery xs + mystery ys :=\n", "sideBar": false, "firstProofLineNumber": 69, "lastProofLineNumber": 78, "textBefore": "import game.lists.level6 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 7 : Structural induction on lists\n-/\n\n/-\nIn a previous level, we show that if a list `ys` has the property that there exists a list `xs`\nfor which `ys = M :: xs`, then `noggin ys = M`.\n\nWe proved this by decomposing `ys` into cases, via the `cases` tactic. This sufficed because the\ndefinition of `noggin` is not truly recursive. That is, `noggin (x :: xs)` does not explicitly\ndepend on `noggin xs`.\n\nIn general, proving results that involve a recursive function requires a more sophisticated\nprinciple called _structural induction_ (or sometimes just _induction_). This is a generalisation\nof the induction principle for natural numbers that you may have seen at school.\n\nStructural induction on lists involves proving two things.\n\n1. Prove the result holds for the nil list.\n2. _Assuming_ that the result hold for a given list `xs`, prove that for every letter `x`, the\nresult holds for the list `x :: xs`.\n\nIn a proof by induction, 1. is called the base case and 2. is called the inductive step.\n-/\n\n/-\nAs a first example, we prove `mystery(ys ++ [x]) = mystery(ys) + 1`, for every letter `x` and\nevery list `ys`.\n\nWe do this by induction on `ys`.\n\n1. The base case is when `ys` is the nil list. We must prove `mystery (nil ++ [x]) = mystery nil + 1`.\n2. For the inductive step, `ys` is `z :: zs` for a letter `z` and a list `zs`.\nWe assume `ih : mystery (zs ++ [x]) = mystery zs + `. This is called the induction hypothesis.\nWe must prove `mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1.`\n\nI've used the `show` tactic in the proof below to indicate the targets of the base case and the\ninductive step. You don't need to do this, but it is recommended for clarity.\n-/\n\n/- Example : no-side-bar\nFor every letter `x` and every list `ys`, we have `mystery(ys ++ [x]) = mystery(ys) + 1`.\n-/\nexample (x : letter) (ys : list letter) : mystery(ys ++ [x]) = mystery(ys) + 1 :=\nbegin\n  induction ys, -- Proof by induction, analysing the variable ys.\n  case nil :            -- The base case.\n  { show mystery (nil ++ [x]) = mystery nil + 1,    \n    simp [mystery] },               \n  case cons : z zs ih   -- The inductive step.\n  { show mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1,\n    simp [mystery, ih], }, \nend\n\n/- Hint : Hint\nTry induction on `xs`.\n-/\n\n\n/- Theorem : no-side-bar\nFor all lists `xs` and `ys`, we have `mystery(xs ++ ys) = mystery xs + mystery ys`\n-/\nexample (xs ys) : mystery(xs ++ ys) = mystery xs + mystery ys :=\nbegin\n", "proof": "  induction xs,\n  case nil :\n  { show mystery (nil ++ ys) = mystery nil + mystery ys,\n    simp [mystery], },\n  case cons : z zs ih\n  { show mystery (z :: zs ++ ys) = mystery (z :: zs) + mystery ys,\n    simp [mystery, ih, add_right_comm], },\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 10, "editorText": "sorry", "lineOffset": 68, "name": "", "statement": "(xs ys) : mystery(xs ++ ys) = mystery xs + mystery ys"}]}, {"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "353", "hidden": true}, {"type": "lean", "content": "354", "hidden": true}, {"type": "text", "content": "355"}, {"type": "text", "content": "356"}, {"type": "text", "content": "357"}, {"type": "axiom", "content": "358", "name": "cons_M_of_derivable", "sideBar": true}, {"type": "lean", "content": "359", "hidden": false}, {"type": "text", "content": "360"}, {"type": "example", "text": "362", "lean": "example : \u00ac (derivable [U, I]) :=\n", "sideBar": false, "firstProofLineNumber": 61, "lastProofLineNumber": 65, "textBefore": "import game.lists.level7 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 8 : Inductively defined propositions\n-/\n\n\n/-\nJust as data (such as lists) can be defined inductively, so propositions can be defined inductively.\n\nWe've been working with an inductively defined proposition throughout this game: the proposition\n`derivable` has a base case, that `[M, I]` is derivable, and four recursive constructors, the\nfour production rules.\n\nThe cases are `derivable_MI`, `r1`, `r2`, `r3`, `r4`. These correspond to the results we've called\n`der_MI`, `rule1`, `rule2`, `rule3`, and `rule4`.\n-/\n\n/-\nBy induction, and using the results `cons_M_MI`, `cons_M_r1`, etc., we'll prove that every\nderivable list starts with an `M`.\n-/\n\n/- Axiom : cons_M_of_derivable\nEvery derivable list starts with an `M`.\n-/\nlemma cons_M_of_derivable {xs : list letter} (h : derivable xs) :\n\u2203 ys, xs = M :: ys :=\nbegin\n  induction h,\n  case derivable_MI         -- The base case.\n  { from cons_M_MI, },\n  case r1 : zs h ih         -- The first inductive case.\n  { apply cons_M_r1 ih, },\n  case r2 : zs h ih         -- The second inductive case.\n  { apply cons_M_r2, },\n  case r3 : zs ws h ih      -- The third inductive case.\n  { apply cons_M_r3 ih, },\n  case r4 : zs ws h ih      -- The fourth inductive case.\n  { apply cons_M_r4 ih, },\nend\n\n/-\nUsing this, we'll prove that `[U, I]` is _not_ derivable. This is our first negative result.begin\nThe symbol `\u00ac` (typed `\\not`) means 'not'.\n\nTo prove a not statement, we _assume_ the statement is true then try to derive a contradiction.\n\nUsing the result `cons_M_of_derivable`, we deduce that there is a list `ys` such that\n`[U, I] = M :: ys`. Call this list `zs` and the hypothesis `hzs : [U, I] = M :: zs`.\nUsing this, we get a contradiction (via `simp * at *`).\n-/\n\n/- Example : no-side-bar\nThe list `[U, I]` is not derivable.\n-/\nexample : \u00ac (derivable [U, I]) :=\nbegin\n", "proof": "  -- We assume `derivable [U, I]`. It remains to prove `false`.\n  assume h : derivable [U, I],\n  have h2 : \u2203 ys, [U, I] = M :: ys, from cons_M_of_derivable h,\n  cases h2 with zs hzs,\n  simp * at *,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- \n### A shortcut\nYou'll note in the proof above that the hypothesis `h2` is introduced via `have` then immediately\ndecomposed via `cases`. The two lines can be combined and the hypothesis `h2` omitted.\n-/\n\nexample : \u00ac (derivable [U, I]) :=\nbegin\n  assume h : derivable [U, I],\n  cases cons_M_of_derivable h with zs hzs,\n  simp * at *,\nend\n\n\n/- Theorem : no-side-bar\nNo list that begins with an `I` is derivable.\n-/\nexample (xs : list letter) : \u00ac (derivable (I :: xs)) :=\nbegin\n  assume h : derivable (I :: xs),\n  cases (cons_M_of_derivable h) with zs hzs,\n  simp * at *,\n\n\nend", "height": 5, "editorText": "361", "lineOffset": 60, "statement": "\u00ac (derivable [U, I])"}, {"type": "text", "content": "363"}, {"type": "lean", "content": "364", "hidden": false}, {"type": "theorem", "text": "365", "lean": "example (xs : list letter) : \u00ac (derivable (I :: xs)) :=\n", "sideBar": false, "firstProofLineNumber": 87, "lastProofLineNumber": 91, "textBefore": "import game.lists.level7 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 8 : Inductively defined propositions\n-/\n\n\n/-\nJust as data (such as lists) can be defined inductively, so propositions can be defined inductively.\n\nWe've been working with an inductively defined proposition throughout this game: the proposition\n`derivable` has a base case, that `[M, I]` is derivable, and four recursive constructors, the\nfour production rules.\n\nThe cases are `derivable_MI`, `r1`, `r2`, `r3`, `r4`. These correspond to the results we've called\n`der_MI`, `rule1`, `rule2`, `rule3`, and `rule4`.\n-/\n\n/-\nBy induction, and using the results `cons_M_MI`, `cons_M_r1`, etc., we'll prove that every\nderivable list starts with an `M`.\n-/\n\n/- Axiom : cons_M_of_derivable\nEvery derivable list starts with an `M`.\n-/\nlemma cons_M_of_derivable {xs : list letter} (h : derivable xs) :\n\u2203 ys, xs = M :: ys :=\nbegin\n  induction h,\n  case derivable_MI         -- The base case.\n  { from cons_M_MI, },\n  case r1 : zs h ih         -- The first inductive case.\n  { apply cons_M_r1 ih, },\n  case r2 : zs h ih         -- The second inductive case.\n  { apply cons_M_r2, },\n  case r3 : zs ws h ih      -- The third inductive case.\n  { apply cons_M_r3 ih, },\n  case r4 : zs ws h ih      -- The fourth inductive case.\n  { apply cons_M_r4 ih, },\nend\n\n/-\nUsing this, we'll prove that `[U, I]` is _not_ derivable. This is our first negative result.begin\nThe symbol `\u00ac` (typed `\\not`) means 'not'.\n\nTo prove a not statement, we _assume_ the statement is true then try to derive a contradiction.\n\nUsing the result `cons_M_of_derivable`, we deduce that there is a list `ys` such that\n`[U, I] = M :: ys`. Call this list `zs` and the hypothesis `hzs : [U, I] = M :: zs`.\nUsing this, we get a contradiction (via `simp * at *`).\n-/\n\n/- Example : no-side-bar\nThe list `[U, I]` is not derivable.\n-/\nexample : \u00ac (derivable [U, I]) :=\nbegin\n  -- We assume `derivable [U, I]`. It remains to prove `false`.\n  assume h : derivable [U, I],\n  have h2 : \u2203 ys, [U, I] = M :: ys, from cons_M_of_derivable h,\n  cases h2 with zs hzs,\n  simp * at *,\nend\n\n/- \n### A shortcut\nYou'll note in the proof above that the hypothesis `h2` is introduced via `have` then immediately\ndecomposed via `cases`. The two lines can be combined and the hypothesis `h2` omitted.\n-/\n\nexample : \u00ac (derivable [U, I]) :=\nbegin\n  assume h : derivable [U, I],\n  cases cons_M_of_derivable h with zs hzs,\n  simp * at *,\nend\n\n\n/- Theorem : no-side-bar\nNo list that begins with an `I` is derivable.\n-/\nexample (xs : list letter) : \u00ac (derivable (I :: xs)) :=\nbegin\n", "proof": "  assume h : derivable (I :: xs),\n  cases (cons_M_of_derivable h) with zs hzs,\n  simp * at *,\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 86, "name": "", "statement": "(xs : list letter) : \u00ac (derivable (I :: xs))"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "366", "hidden": true}, {"type": "lean", "content": "367", "hidden": true}, {"type": "text", "content": "368"}, {"type": "text", "content": "369"}, {"type": "text", "content": "370"}, {"type": "axiom", "content": "371", "name": "not_in_tail_of_not_in_self", "sideBar": true}, {"type": "lean", "content": "372", "hidden": false}, {"type": "axiom", "content": "373", "name": "tail_append_singleton_of_ne_nil", "sideBar": true}, {"type": "text", "content": "374"}, {"type": "text", "content": "375"}, {"type": "lemma", "text": "376", "lean": "lemma M_notin_tail_of_derivable_self {xs : list letter}\n(h : derivable (xs)) : M \u2209 tail xs :=\n", "sideBar": true, "firstProofLineNumber": 77, "lastProofLineNumber": 103, "textBefore": "import game.lists.level8 -- hide\n\nopen letter list -- hide\n\n/-\n## Level 9 : Noggins and tails\n-/\n\n/-\nWe've proved that every derivable list must start with `M`. By now, you've surely noticed that\nno derivable list has an `M` in its 'tail'. By `tail`, I mean the function defined by:\n1. `tail [] = []`,\n2. `tail (x :: xs) = xs`.\n-/\n\n/-\nYou'll prove this result by induction. In addition to one of the results already proved in this\nworld, you'll need the following lemma _and_ you'll need `tail_append_singleton_of_ne_nil`.\n\n`not_in_tail_of_not_in_self` states that if `M` is not in `ws`, then `M` is not in the tail of `ws`.\n\n`tail_append_singleton_of_ne_nil` states that if `xs \u2260 nil` (i.e. `xs` is not `nil`), then\nthe tail of `xs ++ [x]` is `(tail xs) ++ [x]`.\n\n\nNote that `\u2260` is typed `\\ne`.\n-/\n\n/- Axiom : not_in_tail_of_not_in_self\n\u2200 ws, M \u2209 ws \u2192 M \u2209 tail ws\n-/\nlemma not_in_tail_of_not_in_self (ws : list letter)\n(h : M \u2209 ws) : M \u2209 tail ws :=\nbegin\n  cases ws with p ps,\n  { simp * at *, },\n  { simp [*, not_or_distrib] at *, },\nend\n\n/- Axiom : tail_append_singleton_of_ne_nil\n\u2200 xs x, xs \u2260 nil \u2192 tail (xs ++ [x]) = (tail xs) ++ [x]\n-/\n\n\n/-\nYou may wish to use the following as a template for your proof.\n\n```\nexample (xs : list letter)\n(h : derivable (xs)) : M \u2209 tail xs :=\nbegin\n  induction h,\n  case derivable_MI\n  { sorry, },\n  case r1 : zs h ih\n  { sorry, },\n  case r2 : zs h ih  \n  { sorry, },\n  case r3 : zs ws h ih  \n  { sorry, },\n  case r4 : zs ws h ih\n  { sorry, },\nend\n```\n-/\n\n/-\nOk, now it's your turn!\n-/\n\n/- Lemma : M_notin_tail_of_derivable_self\n`M` does not appear in the tail of a derivable list.\n-/\nlemma M_notin_tail_of_derivable_self {xs : list letter}\n(h : derivable (xs)) : M \u2209 tail xs :=\nbegin\n", "proof": "  induction h,\n  case derivable_MI\n  { simp,},\n  case r1 : zs h ih\n  { rw append_IU_eq_append_I_append_U,\n    have h : zs ++ [I] \u2260 nil, simp,\n    rw tail_append_singleton_of_ne_nil h,\n    { simp [ih], }, },\n  case r2 : zs h ih  \n  { simp * at *, },\n  case r3 : zs ws h ih  \n  { cases zs,\n    { simp * at *, },\n    { simp * at *, }, },\n  case r4 : zs ws h ih\n  { cases zs with p ps,\n    { simp [not_in_tail_of_not_in_self, *] at *, },\n    { simp * at *, }, },\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 27, "editorText": "sorry", "lineOffset": 76, "name": "M_notin_tail_of_derivable_self", "statement": "{xs : list letter}\n(h : derivable (xs)) : M \u2209 tail xs"}]}], "parents": [2]}, {"name": "377", "levels": [{"name": "", "problemIndex": 17, "objects": [{"type": "lean", "content": "378", "hidden": true}, {"type": "lean", "content": "379", "hidden": true}, {"type": "text", "content": "380"}, {"type": "text", "content": "381"}, {"type": "text", "content": "382"}, {"type": "lean", "content": "383", "hidden": true}, {"type": "lean", "content": "384", "hidden": false}, {"type": "lean", "content": "385", "hidden": true}, {"type": "text", "content": "386"}, {"type": "example", "text": "388", "lean": "example : count U [M, U, M] = 1 :=\n", "sideBar": false, "firstProofLineNumber": 41, "lastProofLineNumber": 41, "textBefore": "import game.lists.level9 game.remainders.level3 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 1 : Counting\n-/\n\n/-\nTo progress to this world, you should have finished its parents, the Lists and Remainders worlds.\n\nThe aim of this world is to develop a necessary numerical condition for derivability. Using this,\nwe'll resolve the question of the derivability of `\"MU\"`.\n-/\n\n/-\nThe criterion concerns the number of occurrences of a certain letter in a derivable string.\nThe Lean function `count` computes this quantity. Its definition is (roughly) as follows.\n-/\n\nnamespace hidden -- hide\n\ndef count : letter \u2192 list letter \u2192 \u2115\n| y []          :=  0\n| y (x :: xs)   :=  if y = x\n                    then (count y xs) + 1\n                    else (count y xs)\n\nend hidden -- hide\n\n/-\nInformally, `count y xs` is the number of occurrences of letter `y` in list `xs`.\nAs with `mystery`, concrete results about `count` can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe list `[M, U, M]` contains one occurrence of the letter `U`.\n-/\nexample : count U [M, U, M] = 1 :=\nbegin\n", "proof": "  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\n### Proving and statements\nWe've seen how to prove an 'or' statement. To prove `p \u2228 q`, we use either `left` and then prove `p`\nor we use `right` and then prove `q`.\n\nThe symbol `\u2227` stands for `\\and`. To prove `p \u2227 q` we use the `split` tactic. This creates two new\ngoals.\n\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Tactic : split\n## Summary\n`split` is used to prove and statements.\n## Detail\nIf the target is to prove `p \u2227 q`, the `split` tactic creates two new goals.\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x\\\\) and \\\\(y\\\\) are natural numbers (i.e. non-negative integers) such that \\\\(x + y = 0\\\\),\nthen \\\\(x = 0\\\\) and \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0 :=\nbegin\n  split,  -- create two new goals.\n  { show x = 0,     -- The first goal is to prove `x = 0`.\n    simp * at * }, \n  { show y = 0,     -- The second goal is to prove `y = 0`.\n    simp * at *, } \nend\n\n/-\nUsing the two big results from the Lists world, we can prove that `count M xs = 1`, for every\nderivable list `xs`.\n-/\n\n/- Example : no-side-bar\nIf `xs` is derivable, then `count M xs = 1`.\n-/\nexample (ys : list letter) (h : derivable ys) : count M ys = 1 :=\nbegin\n  -- After `cases`, we get `hxs : ys = M :: xs`.\n  cases (cons_M_of_derivable h) with xs hxs, \n  rw hxs, -- The target becomes is `\u22a2 count M (M :: xs) = 1`\n  have h2 : M \u2209 tail ys, from M_notin_tail_of_derivable_self h,\n  simp * at *,\nend\n\n/-\nYour task is to find a list `xs` such that `xs` has exactly three occurrences of `U`\n_and_ such that `xs` is derivable.\n-/\n\n/- Hint : Hint\nStart with `use` to introduce the string (if you're using a list, remember to use double brackets).\n\nThen use `split` to decompose the goal into two new goals.\n\nRemeber that the `repeat` function can help with expressing repeated letters.\n-/\n\n/- Theorem : no-side-bar\nThere exists a list `xs` such that `count U xs = 3` and `xs` is derivable.\n-/\nexample : \u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs):=\nbegin\n  use [[M, U, U, U] ++ repeat I 7],\n  split,\n  { refl, },\n  { apply rule3 [M, U, U],\n    apply rule3 [M, U],\n    apply rule3 [M],\n    apply rule2 (repeat I 8),\n    apply rule2 (repeat I 4),\n    apply rule2 (repeat I 2),\n    from der_MII, }\n\n\n\n\n\n\n\n\n\n\nend\n\n\n", "height": 1, "editorText": "387", "lineOffset": 40, "statement": "count U [M, U, M] = 1"}, {"type": "text", "content": "389"}, {"type": "tactic", "content": "390", "name": "split", "sideBar": true}, {"type": "example", "text": "392", "lean": "example (x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0 :=\n", "sideBar": false, "firstProofLineNumber": 72, "lastProofLineNumber": 76, "textBefore": "import game.lists.level9 game.remainders.level3 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 1 : Counting\n-/\n\n/-\nTo progress to this world, you should have finished its parents, the Lists and Remainders worlds.\n\nThe aim of this world is to develop a necessary numerical condition for derivability. Using this,\nwe'll resolve the question of the derivability of `\"MU\"`.\n-/\n\n/-\nThe criterion concerns the number of occurrences of a certain letter in a derivable string.\nThe Lean function `count` computes this quantity. Its definition is (roughly) as follows.\n-/\n\nnamespace hidden -- hide\n\ndef count : letter \u2192 list letter \u2192 \u2115\n| y []          :=  0\n| y (x :: xs)   :=  if y = x\n                    then (count y xs) + 1\n                    else (count y xs)\n\nend hidden -- hide\n\n/-\nInformally, `count y xs` is the number of occurrences of letter `y` in list `xs`.\nAs with `mystery`, concrete results about `count` can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe list `[M, U, M]` contains one occurrence of the letter `U`.\n-/\nexample : count U [M, U, M] = 1 :=\nbegin\n  refl,\nend\n\n\n/-\n### Proving and statements\nWe've seen how to prove an 'or' statement. To prove `p \u2228 q`, we use either `left` and then prove `p`\nor we use `right` and then prove `q`.\n\nThe symbol `\u2227` stands for `\\and`. To prove `p \u2227 q` we use the `split` tactic. This creates two new\ngoals.\n\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Tactic : split\n## Summary\n`split` is used to prove and statements.\n## Detail\nIf the target is to prove `p \u2227 q`, the `split` tactic creates two new goals.\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x\\\\) and \\\\(y\\\\) are natural numbers (i.e. non-negative integers) such that \\\\(x + y = 0\\\\),\nthen \\\\(x = 0\\\\) and \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0 :=\nbegin\n", "proof": "  split,  -- create two new goals.\n  { show x = 0,     -- The first goal is to prove `x = 0`.\n    simp * at * }, \n  { show y = 0,     -- The second goal is to prove `y = 0`.\n    simp * at *, } ", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nUsing the two big results from the Lists world, we can prove that `count M xs = 1`, for every\nderivable list `xs`.\n-/\n\n/- Example : no-side-bar\nIf `xs` is derivable, then `count M xs = 1`.\n-/\nexample (ys : list letter) (h : derivable ys) : count M ys = 1 :=\nbegin\n  -- After `cases`, we get `hxs : ys = M :: xs`.\n  cases (cons_M_of_derivable h) with xs hxs, \n  rw hxs, -- The target becomes is `\u22a2 count M (M :: xs) = 1`\n  have h2 : M \u2209 tail ys, from M_notin_tail_of_derivable_self h,\n  simp * at *,\nend\n\n/-\nYour task is to find a list `xs` such that `xs` has exactly three occurrences of `U`\n_and_ such that `xs` is derivable.\n-/\n\n/- Hint : Hint\nStart with `use` to introduce the string (if you're using a list, remember to use double brackets).\n\nThen use `split` to decompose the goal into two new goals.\n\nRemeber that the `repeat` function can help with expressing repeated letters.\n-/\n\n/- Theorem : no-side-bar\nThere exists a list `xs` such that `count U xs = 3` and `xs` is derivable.\n-/\nexample : \u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs):=\nbegin\n  use [[M, U, U, U] ++ repeat I 7],\n  split,\n  { refl, },\n  { apply rule3 [M, U, U],\n    apply rule3 [M, U],\n    apply rule3 [M],\n    apply rule2 (repeat I 8),\n    apply rule2 (repeat I 4),\n    apply rule2 (repeat I 2),\n    from der_MII, }\n\n\n\n\n\n\n\n\n\n\nend\n\n\n", "height": 5, "editorText": "391", "lineOffset": 71, "statement": "(x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0"}, {"type": "text", "content": "393"}, {"type": "example", "text": "395", "lean": "example (ys : list letter) (h : derivable ys) : count M ys = 1 :=\n", "sideBar": false, "firstProofLineNumber": 89, "lastProofLineNumber": 93, "textBefore": "import game.lists.level9 game.remainders.level3 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 1 : Counting\n-/\n\n/-\nTo progress to this world, you should have finished its parents, the Lists and Remainders worlds.\n\nThe aim of this world is to develop a necessary numerical condition for derivability. Using this,\nwe'll resolve the question of the derivability of `\"MU\"`.\n-/\n\n/-\nThe criterion concerns the number of occurrences of a certain letter in a derivable string.\nThe Lean function `count` computes this quantity. Its definition is (roughly) as follows.\n-/\n\nnamespace hidden -- hide\n\ndef count : letter \u2192 list letter \u2192 \u2115\n| y []          :=  0\n| y (x :: xs)   :=  if y = x\n                    then (count y xs) + 1\n                    else (count y xs)\n\nend hidden -- hide\n\n/-\nInformally, `count y xs` is the number of occurrences of letter `y` in list `xs`.\nAs with `mystery`, concrete results about `count` can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe list `[M, U, M]` contains one occurrence of the letter `U`.\n-/\nexample : count U [M, U, M] = 1 :=\nbegin\n  refl,\nend\n\n\n/-\n### Proving and statements\nWe've seen how to prove an 'or' statement. To prove `p \u2228 q`, we use either `left` and then prove `p`\nor we use `right` and then prove `q`.\n\nThe symbol `\u2227` stands for `\\and`. To prove `p \u2227 q` we use the `split` tactic. This creates two new\ngoals.\n\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Tactic : split\n## Summary\n`split` is used to prove and statements.\n## Detail\nIf the target is to prove `p \u2227 q`, the `split` tactic creates two new goals.\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x\\\\) and \\\\(y\\\\) are natural numbers (i.e. non-negative integers) such that \\\\(x + y = 0\\\\),\nthen \\\\(x = 0\\\\) and \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0 :=\nbegin\n  split,  -- create two new goals.\n  { show x = 0,     -- The first goal is to prove `x = 0`.\n    simp * at * }, \n  { show y = 0,     -- The second goal is to prove `y = 0`.\n    simp * at *, } \nend\n\n/-\nUsing the two big results from the Lists world, we can prove that `count M xs = 1`, for every\nderivable list `xs`.\n-/\n\n/- Example : no-side-bar\nIf `xs` is derivable, then `count M xs = 1`.\n-/\nexample (ys : list letter) (h : derivable ys) : count M ys = 1 :=\nbegin\n", "proof": "  -- After `cases`, we get `hxs : ys = M :: xs`.\n  cases (cons_M_of_derivable h) with xs hxs, \n  rw hxs, -- The target becomes is `\u22a2 count M (M :: xs) = 1`\n  have h2 : M \u2209 tail ys, from M_notin_tail_of_derivable_self h,\n  simp * at *,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nYour task is to find a list `xs` such that `xs` has exactly three occurrences of `U`\n_and_ such that `xs` is derivable.\n-/\n\n/- Hint : Hint\nStart with `use` to introduce the string (if you're using a list, remember to use double brackets).\n\nThen use `split` to decompose the goal into two new goals.\n\nRemeber that the `repeat` function can help with expressing repeated letters.\n-/\n\n/- Theorem : no-side-bar\nThere exists a list `xs` such that `count U xs = 3` and `xs` is derivable.\n-/\nexample : \u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs):=\nbegin\n  use [[M, U, U, U] ++ repeat I 7],\n  split,\n  { refl, },\n  { apply rule3 [M, U, U],\n    apply rule3 [M, U],\n    apply rule3 [M],\n    apply rule2 (repeat I 8),\n    apply rule2 (repeat I 4),\n    apply rule2 (repeat I 2),\n    from der_MII, }\n\n\n\n\n\n\n\n\n\n\nend\n\n\n", "height": 5, "editorText": "394", "lineOffset": 88, "statement": "(ys : list letter) (h : derivable ys) : count M ys = 1"}, {"type": "text", "content": "396"}, {"type": "hint", "content": "397", "title": "398"}, {"type": "theorem", "text": "399", "lean": "example : \u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs):=\n", "sideBar": false, "firstProofLineNumber": 114, "lastProofLineNumber": 133, "textBefore": "import game.lists.level9 game.remainders.level3 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 1 : Counting\n-/\n\n/-\nTo progress to this world, you should have finished its parents, the Lists and Remainders worlds.\n\nThe aim of this world is to develop a necessary numerical condition for derivability. Using this,\nwe'll resolve the question of the derivability of `\"MU\"`.\n-/\n\n/-\nThe criterion concerns the number of occurrences of a certain letter in a derivable string.\nThe Lean function `count` computes this quantity. Its definition is (roughly) as follows.\n-/\n\nnamespace hidden -- hide\n\ndef count : letter \u2192 list letter \u2192 \u2115\n| y []          :=  0\n| y (x :: xs)   :=  if y = x\n                    then (count y xs) + 1\n                    else (count y xs)\n\nend hidden -- hide\n\n/-\nInformally, `count y xs` is the number of occurrences of letter `y` in list `xs`.\nAs with `mystery`, concrete results about `count` can be proved by reflexivity.\n-/\n\n/- Example : no-side-bar\nThe list `[M, U, M]` contains one occurrence of the letter `U`.\n-/\nexample : count U [M, U, M] = 1 :=\nbegin\n  refl,\nend\n\n\n/-\n### Proving and statements\nWe've seen how to prove an 'or' statement. To prove `p \u2228 q`, we use either `left` and then prove `p`\nor we use `right` and then prove `q`.\n\nThe symbol `\u2227` stands for `\\and`. To prove `p \u2227 q` we use the `split` tactic. This creates two new\ngoals.\n\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Tactic : split\n## Summary\n`split` is used to prove and statements.\n## Detail\nIf the target is to prove `p \u2227 q`, the `split` tactic creates two new goals.\n1. To prove `p`.\n2. To prove `q`.\n-/\n\n/- Example : no-side-bar\nIf \\\\(x\\\\) and \\\\(y\\\\) are natural numbers (i.e. non-negative integers) such that \\\\(x + y = 0\\\\),\nthen \\\\(x = 0\\\\) and \\\\(y = 0.\\\\)\n-/\nexample (x y : \u2115) (h : x + y = 0) : x = 0 \u2227 y = 0 :=\nbegin\n  split,  -- create two new goals.\n  { show x = 0,     -- The first goal is to prove `x = 0`.\n    simp * at * }, \n  { show y = 0,     -- The second goal is to prove `y = 0`.\n    simp * at *, } \nend\n\n/-\nUsing the two big results from the Lists world, we can prove that `count M xs = 1`, for every\nderivable list `xs`.\n-/\n\n/- Example : no-side-bar\nIf `xs` is derivable, then `count M xs = 1`.\n-/\nexample (ys : list letter) (h : derivable ys) : count M ys = 1 :=\nbegin\n  -- After `cases`, we get `hxs : ys = M :: xs`.\n  cases (cons_M_of_derivable h) with xs hxs, \n  rw hxs, -- The target becomes is `\u22a2 count M (M :: xs) = 1`\n  have h2 : M \u2209 tail ys, from M_notin_tail_of_derivable_self h,\n  simp * at *,\nend\n\n/-\nYour task is to find a list `xs` such that `xs` has exactly three occurrences of `U`\n_and_ such that `xs` is derivable.\n-/\n\n/- Hint : Hint\nStart with `use` to introduce the string (if you're using a list, remember to use double brackets).\n\nThen use `split` to decompose the goal into two new goals.\n\nRemeber that the `repeat` function can help with expressing repeated letters.\n-/\n\n/- Theorem : no-side-bar\nThere exists a list `xs` such that `count U xs = 3` and `xs` is derivable.\n-/\nexample : \u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs):=\nbegin\n", "proof": "  use [[M, U, U, U] ++ repeat I 7],\n  split,\n  { refl, },\n  { apply rule3 [M, U, U],\n    apply rule3 [M, U],\n    apply rule3 [M],\n    apply rule2 (repeat I 8),\n    apply rule2 (repeat I 4),\n    apply rule2 (repeat I 2),\n    from der_MII, }\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n", "height": 20, "editorText": "sorry", "lineOffset": 113, "name": "", "statement": "\u2203 (xs : list letter), (count U xs = 3) \u2227 (derivable xs)"}]}, {"name": "", "problemIndex": 10, "objects": [{"type": "lean", "content": "400", "hidden": true}, {"type": "lean", "content": "401", "hidden": true}, {"type": "text", "content": "402"}, {"type": "text", "content": "403"}, {"type": "text", "content": "404"}, {"type": "text", "content": "405"}, {"type": "lean", "content": "406", "hidden": false}, {"type": "text", "content": "407"}, {"type": "text", "content": "408"}, {"type": "tactic", "content": "409", "name": "unfold", "sideBar": true}, {"type": "lemma", "text": "410", "lean": "lemma cieq_MI : cieq ([M, I]) :=\n", "sideBar": true, "firstProofLineNumber": 71, "lastProofLineNumber": 75, "textBefore": "import game.counting.level1-- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 2 : Counting occurrences of `I`\n-/\n\n/-\nIn the last level, we saw that every derivable list has exactly one occurrence of `M`.\n\nIf you did the problem from that level, you should be able to convince yourself (though the Lean\nproof takes some work), that for every natural number `n`, there exists a derivable list `xs`\nwith exactly `n` occurrences of `U`.\n\nThe real question concerns the number of occurrences of `I`. If you haven't examined this yet,\ngo back and look at some examples. What do you notice?\n-/\n\n/-\nThe only count values we've seen so far for `I`s in derivable lists are: 1, 2, 4, 5, 7, 8, 10, 11, ...\n\nThe pattern here is that we have every possibility *except* multiples of 3.\n\nAnother way to state this conjecture is that if `xs` is derivable, then `count I xs` should leave\nremainder 1 or 2 on division by 3.\n\nAs in the Lists world, we'll prove this by induction on the hypothesis that `xs` is derivable.\n-/\n\n/-\nTo make our proofs concise, we introduce a predicate that represents the notion in which we\nare interested.\n-/\n\ndef cieq (xs : list letter) :=\n(count I xs % 3) = 1 \u2228 (count I xs % 3) = 2\n\n/-\nGiven this definition, our aim is to prove `cieq xs` holds for every derivable list `xs`.\n\nIn this level, we start with the base case.\n-/\n\n/- \nIf you ever get confused regarding how a definition applies, you can type `unfold f` to\nexpand out the definition. In this case, you can (though it isn't necessary) type\n`unfold cieq` as the first line of your proof.\n\nIn future levels, `unfold cieq at *` can be used to unfold `cieq` everywhere.\n-/\n\n/- Tactic : unfold\n## Summary\n`unfold` expands a given definition.\n## Details\nIf the target contains (say) the function `cieq`, then `unfold cieq` will replace `cieq`\nwith its definition.\n\nType `unfold cieq at h` to unfold `cieq` at hypothesis `h`.\n\nType `unfold cieq at *` to unfold `cieq` at the target and at every hypothesis.\n\n-/\n\n/- Lemma : cieq_MI\n`cieq ([M, I])` holds.\n-/\nlemma cieq_MI : cieq ([M, I]) :=\nbegin\n", "proof": "  unfold cieq,\n  left,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 5, "editorText": "sorry", "lineOffset": 70, "name": "cieq_MI", "statement": "cieq ([M, I])"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "411", "hidden": true}, {"type": "lean", "content": "412", "hidden": true}, {"type": "text", "content": "413"}, {"type": "text", "content": "414"}, {"type": "hint", "content": "415", "title": "416"}, {"type": "lemma", "text": "417", "lean": "lemma cieq_r1 {xs} (h : cieq (xs ++ [I])) : cieq (xs ++ [I, U]) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 28, "textBefore": "import game.counting.level2 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 3 : Counting occurrences of `I`, rule 1\n-/\n\n/-\nYou know the drill. We're moving on to prove the result for rule 1.\nThat is is, we show that if a list is constructed by rule 1 from a list that satisfies `cieq`,\nthen so does the constructed list.\n-/\n\n/- Hint : Hint\nStart by applying the big result we proved in Remainders world.\n-/\n\n/- Lemma : cieq_r1\nIf `cieq (xs ++ [I])` holds, then so does `cieq (xs ++ [I, U])`.\n-/\nlemma cieq_r1 {xs} (h : cieq (xs ++ [I])) : cieq (xs ++ [I, U]) :=\nbegin\n", "proof": "  apply mod3_eq_1_or_mod3_eq_2 h,\n  left,\n  simp,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 23, "name": "cieq_r1", "statement": "{xs} (h : cieq (xs ++ [I])) : cieq (xs ++ [I, U])"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "418", "hidden": true}, {"type": "lean", "content": "419", "hidden": true}, {"type": "text", "content": "420"}, {"type": "hint", "content": "421", "title": "422"}, {"type": "lemma", "text": "423", "lean": "lemma cieq_r2 {xs} (h : cieq (M :: xs)) : cieq (M :: xs ++ xs) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 25, "textBefore": "import game.counting.level3 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 4 : Counting occurrences of `I`, rule 2\n-/\n\n\n/- Hint : Hint\nIt may help to use the result `two_mul` which states\n`\u2200 x, 2 * x = x + x`.\n-/\n\n/- Lemma : cieq_r2\nIf `cieq (xs ++ [I])` holds, then so does `cieq (xs ++ [I, U])`.\n-/\nlemma cieq_r2 {xs} (h : cieq (M :: xs)) : cieq (M :: xs ++ xs) :=\nbegin\n", "proof": "  apply mod3_eq_1_or_mod3_eq_2 h,\n  right,\n  simp [two_mul], \n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 6, "editorText": "sorry", "lineOffset": 19, "name": "cieq_r2", "statement": "{xs} (h : cieq (M :: xs)) : cieq (M :: xs ++ xs)"}]}, {"name": "", "problemIndex": 12, "objects": [{"type": "lean", "content": "424", "hidden": true}, {"type": "lean", "content": "425", "hidden": true}, {"type": "text", "content": "426"}, {"type": "text", "content": "427"}, {"type": "text", "content": "428"}, {"type": "axiom", "content": "429", "name": "count_III", "sideBar": true}, {"type": "lean", "content": "430", "hidden": false}, {"type": "axiom", "content": "431", "name": "count_I_cons_U", "sideBar": true}, {"type": "lean", "content": "432", "hidden": false}, {"type": "axiom", "content": "433", "name": "add_right_comm", "sideBar": true}, {"type": "axiom", "content": "434", "name": "add_mod_right", "sideBar": true}, {"type": "axiom", "content": "435", "name": "count_append", "sideBar": true}, {"type": "lemma", "text": "436", "lean": "lemma cieq_r3 {xs ys} (h : cieq (xs ++ [I,I,I] ++ ys)) :\ncieq (xs ++ U :: ys) :=\n", "sideBar": true, "firstProofLineNumber": 57, "lastProofLineNumber": 65, "textBefore": "import game.counting.level4 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 5 : Counting occurrences of `I`, rule 3\n-/\n\n\n/-\nFor this problem, `simp` will cause issues as it will perform simplifications that\ndon't help. You can either stick with `rw` or use `simp only`. This latter tactic only uses\nthe specified hypotheses or lemmas for rewriting.\n-/\n\n/-\nFor this level, you'll need to rewrite with the theorems `count_append`,\n`add_right_comm`, and `add_mod_right`. These are described in the sidebar.\n\nYou'll find the two results `count_III` and `count_I_cons_U` below to be helpful.\n-/\n\n\n/- Axiom : count_III\n-/\nlemma count_III : count I [I, I, I] = 3 :=\nbegin\n  refl,\nend\n\n/- Axiom : count_I_cons_U\n-/\nlemma count_I_cons_U (ys : list letter) :\ncount I (U :: ys) = count I ys :=\nbegin\n  simp,\nend\n\n/- Axiom : add_right_comm\n(a + b) + c = (a + c) + b\n-/\n\n/- Axiom : add_mod_right\n(x + z) % z = x % z\n-/\n\n/- Axiom : count_append\ncount a (xs ++ ys) = count a xs + count a ys\n-/\n\n/- Lemma : cieq_r3\nIf `cieq (xs ++ [I,I,I] ++ ys)` holds, then so does `cieq (xs ++ U :: ys)`.\n-/\nlemma cieq_r3 {xs ys} (h : cieq (xs ++ [I,I,I] ++ ys)) :\ncieq (xs ++ U :: ys) :=\nbegin\n", "proof": "  apply mod3_eq_1_or_mod3_eq_2 h,\n  left, clear h,\n  rw [count_append, count_append, count_append, count_III, count_I_cons_U],\n  -- simp only [count_append, count_III, count_I_cons_U],\n  rw [add_right_comm, add_mod_right],\n \n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 9, "editorText": "sorry", "lineOffset": 56, "name": "cieq_r3", "statement": "{xs ys} (h : cieq (xs ++ [I,I,I] ++ ys)) :\ncieq (xs ++ U :: ys)"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "437", "hidden": true}, {"type": "lean", "content": "438", "hidden": true}, {"type": "text", "content": "439"}, {"type": "text", "content": "440"}, {"type": "hint", "content": "441", "title": "442"}, {"type": "lemma", "text": "443", "lean": "lemma cieq_r4 {xs ys} (h : cieq (xs ++ [U, U] ++ ys)) :\ncieq (xs ++ ys) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 31, "textBefore": "import game.counting.level5 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 6 : Counting occurrences of `I`, rule 4\n-/\n\n/-\nSome of the comments from the previous level, regarding rule 3, also apply to this level.\n-/\n\n/- Hint : Hint\nIf you need a result similar to `count_III` from the previous level, remember that you can\nintroduce hypotheses into the context using the `have` tactic.\n-/\n\n/- Lemma : cieq_r4\nIf `cieq (xs ++ [U, U] ++ ys)` holds, then so does `cieq (xs ++ ys)`.\n-/\nlemma cieq_r4 {xs ys} (h : cieq (xs ++ [U, U] ++ ys)) :\ncieq (xs ++ ys) :=\nbegin\n", "proof": "  apply mod3_eq_1_or_mod3_eq_2 h,\n  left,\n  have h2 : count I [U, U] = 0, refl,\n  --rw [count_append, count_append, count_append, h2, add_zero],\n  simp only [count_append, h2, add_zero],\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 23, "name": "cieq_r4", "statement": "{xs ys} (h : cieq (xs ++ [U, U] ++ ys)) :\ncieq (xs ++ ys)"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "444", "hidden": true}, {"type": "lean", "content": "445", "hidden": true}, {"type": "text", "content": "446"}, {"type": "text", "content": "447"}, {"type": "text", "content": "448"}, {"type": "lemma", "text": "449", "lean": "lemma cieq_of_derivable {xs} (h : derivable xs) : cieq xs :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 60, "textBefore": "import game.counting.level6 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 7 : Counting occurrences of `I`, putting it together\n-/\n\n/-\nBy induction, we'll bring together the small results proved in this world to give a\nbig result!\n\nNamely, we'll show that if `xs` is derviable, then `cieq xs` holds. That is,\n`count I xs % 3` is 1 or 2.\n-/\n\n/-\nIf you like, you can use the text below as a template for your proof.\n\n```\nexample {xs : list letter}\n(h : derivable xs) : cieq xs :=\nbegin\n  induction h,\n  case derivable_MI\n  { sorry, },\n  case r1 : zs h ih\n  { sorry, },\n  case r2 : zs h ih  \n  { sorry, },\n  case r3 : zs ws h ih  \n  { sorry, },\n  case r4 : zs ws h ih\n  { sorry, },\nend\n```\n-/\n\n\n/- Lemma : cieq_of_derivable\nIf `xs` is derivable, then `cieq xs` holds.\n-/\nlemma cieq_of_derivable {xs} (h : derivable xs) : cieq xs :=\nbegin\n", "proof": "  induction h,\n  case derivable_MI\n  { from cieq_MI, },\n  case r1 : zs h ih\n  { apply cieq_r1 ih, },\n  case r2 : zs h ih  \n  { apply cieq_r2 ih, },\n  case r3 : zs ws h ih  \n  { apply cieq_r3 ih, },\n  case r4 : zs ws h ih\n  { apply cieq_r4 ih, },\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 16, "editorText": "sorry", "lineOffset": 44, "name": "cieq_of_derivable", "statement": "{xs} (h : derivable xs) : cieq xs"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "450", "hidden": true}, {"type": "lean", "content": "451", "hidden": true}, {"type": "text", "content": "452"}, {"type": "text", "content": "453"}, {"type": "hint", "content": "454", "title": "455"}, {"type": "lemma", "text": "456", "lean": "lemma not_der_MU : \u00ac (derivable [M, U]) :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 31, "textBefore": "import game.counting.level7 -- hide\n\nopen letter list nat -- hide\n\n/-\n## Level 8 : The `\"MU\"` puzzle\n-/\n\n/-\nFinally, we can answer the `\"MU\"` puzzle. That is, we can determine\nwhether `\"MU\"` is derivable.\n-/\n\n/- Hint : Hint\nYou may need to use the `unfold` tactic to expand the definition of `cieq`.\n-/\n\n\n/- Lemma : not_der_MU\n`\"MU\"` is not derivable.\n-/\nlemma not_der_MU : \u00ac (derivable [M, U]) :=\nbegin\n", "proof": "  assume h : derivable \"MU\",\n  have h2 : cieq [M, U], from cieq_of_derivable h,\n  unfold cieq at h2,\n  simp * at *,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 8, "editorText": "sorry", "lineOffset": 23, "name": "not_der_MU", "statement": "\u00ac (derivable [M, U])"}]}], "parents": [3, 4]}], "texts": [["MIU Game", "# MIU game in Lean, version 1.1.2\n\n## By Gihan Marasingha\n\nThis game is an introduction to formal deduction. It is based on the\n[MIU formal system](https://en.wikipedia.org/wiki/MU_puzzle) introduced by Douglas\nHofstadter in the first chapter of his 1979 book,\n[G\u00f6del, Escher, Bach](https://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach).\n\nIn playing this game, you'll be using and learning the language of the Lean interactive theorem prover.\n\nThe game also introduces basic concepts in logic: dealing with and, or, and not statements,\nexistential and universal quantifiers. You'll apply this to solving equations.\n\nYou'll learn how to work with equations involving remainders. This is an introduction to elementary\nideas in number theory.\n\nFinally, you'll see how to work with mathematical induction in a generalised form called\nstructural induction.\n\n\n## The MIU System\n\nThe MIU language has an alphabet of three letters: `M`, `I` and `U`. Just as in English, not\nevery string of letters is a 'word'.\n\nTo create our language, we're given a starting word `\"MI\"` and four 'production rules' that specify\nhow other words can be derived.\n\nThe four rules are:\n\n1. xI \u2192 xIU,\n2. Mx \u2192 Mxx,\n3. xIIIy \u2192 xUy,\n4. xUUy \u2192 xy,\n\nwhere the notation \u03b1 \u2192 \u03b2 is to be interpreted as 'if string \u03b1 is derivable, then string \u03b2 is derivable'.\n\nFor example, `\"MII\"` is derivable by applying rule 2 to the base string `\"MI\"`.\n\nThe aim of the game is to find a simple arithmetic criterion for determining the words (the derivable strings)\nof MIU. In particular, you'll answer the question, 'is `\"MU\"` a word?'\n\n## Playing the game\n\nPress the blue disc on the right to get started. It takes you to the first\nworld of this game. Worlds you've finished are shown as green discs, unfinished worlds as grey.\nYou don't have to complete a level or world to move to the next one. \n\n\n## Credits\n\nThis game was made using the\n<a href=\"https://github.com/mpedramfar/Lean-game-maker\">Lean Game Maker</a> by Mohammad Pedramfar.\n\n<a href=\"https://leanprover.github.io/\" target=\"blank\">Lean</a> is an interactive theorem prover developed at Microsoft Research under the direction of\nLeonardo de Moura.\n\nMathlib, Lean's mathematical library, is developed by the <a href=\"https://leanprover-community.github.io/\" target=\"blank\">Lean community</a>.\n\nThanks to Barrie Cooper for his feedback and suggestions.\n", "/-\nHere's some mathematics in MathJax, just to remind me that it's possible.\nFirst inline: \\\\(a^2 + b^2 = c^2\\\\). Now displayed:\n\\\\[ \\int_{-\\infty}^\\infty  e^{-x^2} dx = \\sqrt \\pi. \\\\]\n-/\n", "Rule practice", "import miu.basic -- hide\n", "## Level 1: The base case and the from tactic\n", "open letter -- hide\n", "The starting point of the MIU system is the assertion that `\"MI\"` is derivable. This\nfact is called `der_MI`.\n\nA description of `der_MI`, and the other rules of the system, can be seen in the _Theorem statements_ drop-down\nmenu at the left of the screen.\nAs you progress through this game, new results will be added to the menu.\n", "", "lemma der_MI : derivable [M, I] := derivable.derivable_MI -- hide\n", "", "lemma rule1 (x) (h : derivable (x ++ [I])) : derivable (x ++ [I, U]) := derivable.r1 h -- hide\n", "", "lemma rule2 (x) (h : derivable (M :: x)) : derivable (M :: x ++ x) := derivable.r2 h -- hide\n", "", "lemma rule3 (x) {y} (h : derivable (x ++ \"III\" ++ y)) : derivable (x ++ (U :: y)) := derivable.r3 h -- hide\n", "", "lemma rule4 (x) {y} (h : derivable (x ++ \"UU\" ++ y)) : derivable (x ++ y) := derivable.r4 h -- hide\n", "Below, we're going to use this fact, trivially, to prove `\"MI\"` is derivable.\n\nDelete the word `sorry` below. The top pane on the right will display the current goal,\n`derivable \"MI\"`. You'll see an error message in the bottom-right pane. Don't panic; this just\nmeans the proof is incomplete.\n\nFinish the proof by typing `from der_MI,` in place of the `sorry`. Don't forget the comma at the end of the\nsentence.\n\nThe error message will disappear and the top pane will display 'Proof complete!'. If 'no goals' is\ndisplayed instead, press the enter key to add a blank line at the end of the proof.\n\nCongratulations, you've finished your first proof! Move on to the next level by using the button\nin the top right.\n", "## Summary\n`from` is a finishing move used to close a goal.\n## Details\nIf `h` is a proof of the target, `from h,` will close the goal.\n", "The string `\"MI\"` is derivable.\n", "## Tactics\n\n`from` is a _tactic_. The `from` tactic is a finishing move used to close a goal by providing a \nproof of the target. \nNotes on tactics will be added to the _Tactics_ drop-down menu on the left.\n", "import game.rule_practice.level1 -- hide\n", "open letter -- hide\n", "## Level 2: Rule 1 and the apply tactic\n", "The first rule of the MIU system states \nthat if xI is derivable, then xIU is derivable, for any string x.\n", "Below, replace `sorry` with `apply rule1 \"M\",` (don't forget the comma).\nThis applies rule 1 with `\"M\"` in place of x.\n\nThe inital target of proving `\"MIU\"` is replaced with the target of proving `\"MI\"` is derivable\n(this is displayed as the goal `derivable (\"M\" ++ [I])`).\n\nBut `der_MI` is a proof of this fact! To use this result, type\n`from der_MI,` on the next line.\n", "## Summary\n`apply` transforms the target using a supplied theorem.\n## Details\nSuppose the theorem `h` states 'if `p`, then `q`'. If the target is to prove `q`,\nthen `apply h` changes the target to `p`.\n\nThis tactic is used for _backward reasoning_.\n", "`\"MIU\"` is derivable\n", "## Backward reasoning\n\nWhen we used the `apply` tactic, we employed _backward reasoning_. Initially, the target was to\nprove `\"MIU\"` is derivable. Rule 1 tells us that if xI is derivable, then so is xIU. Taking\n`\"M\"` for x makes xIU match the target. Thus, applying rule 1, it suffices to prove the intermediate goal that `\"MI\"`\nis derivable.\n", "import game.rule_practice.level2 -- hide\n", "open letter -- hide\n", "## Level 3: Introducing hypotheses with the have tactic\n", "In the previous level, we started with the target of showing `\"MIU\"` is derivable and\nwe used the `apply` tactic with rule 1 to reason _backward_, replacing the target of deriving\n`\"MIU\"` with the target of deriving `\"MI\"`\n", "In this level, we use the `have` tactic to reason _forward_.\n", "Type\n```\nhave h : derivable \"MI\", from der_MI,\n```\nas the first line of the proof below. You'll see that the top-right pane changes to show\n```\nh : derivable \"MI\"\n\u22a2 derivable \"MIU\"\n```\nThe target hasn't changed, but now we have `h`, a proof of `derivable \"MI\"`.\n\nRecall rule 1 states that if xI is derivable, then so is xIU.\nFor the next line, type\n```\nfrom rule1 \"M\" h,\n```\nThis closes the goal using rule 1 with `\"M\"` in place of x and `h` as the proof that `\"MI\"` (i.e. xI)\nis derivable.\n", "## Summary\n`have` introduces a new hypothesis into the context.\n## Details\nIf `t` is a proof of proposition `\u03b1`, then `have h : \u03b1, from t` introduces `h`, a proof of\n`\u03b1` into the context.\n## Example\n\n", "`\"MIU\"` is derivable\n", "## A quicker forward proof\n\nThere's a one-line forward proof. Here, the proof of `h` is `der_MI`. Thus, we can replace the\nsecond line with\n```\nfrom rule1 \"M\" der_MI,\n```\nand then delete the `have` line.\n", "import game.rule_practice.level3 -- hide\n", "open letter -- hide\n", "## Level 4: Rule 2\n", "Rule 2 states derivable Mx \u2192 derivable Mxx. \n", "You can solve the following problem in (at least) one of two ways.\n\n1. Type `apply rule2 x,` with an approriate choice of `x`. This leaves a goal that you can\nclose in one line, using a previous result.\n\n2. Using `from rule2 x t,` with appropriate `x` and `t` gives a one-line proof.\n", "\n", "`\"MII\"` is derivable.\n", "import game.rule_practice.level4 -- hide\n", "open letter -- hide\n", "## Level 5: Rule 2 practice\n", "Prove \"MIUIUIUIU\" is derivable. You'll need more than one\napplication of rule 2. Don't forget you can use any of the results\nlisted in the _Theorem statements_ drop-down menu.\n", "You can prove this either (1) backward, using `apply` in your first line or (2) forward, using\n`have` in your first line. Try both approaches.\n\n**Note** in a forward proof, you can use an underscore (`_`) in place of the rule 2 variable x. Lean\nwill infer the correct value.\n", "The first line of a backward proof should take the form\n```\napply rule2 x,\n```\nfor some string `x` such that the target takes the form Mxx\n", "Hint for backward proof", "Use the following as the first line of a forward proof.\n```\nhave h : derivable \"MIUIU\", from rule2 _ t\n```\nt is the name of a theorem that Mx is derivable, where the target is Mxx.\n", "Hint for forward proof", "`\"MIUIUIUIU\"` is derivable\n", "example : derivable \"MIUIUIUIU\" :=\nbegin\n  have h : derivable \"MIUIU\", from rule2 _ der_MIU,\n  from rule2 _ h,\nend\n", "import game.rule_practice.level5 -- hide\n", "open letter -- hide\n", "## Level 6: Further practice with rules 1 and 2\n", "Now for some fun. Let's prove \"MIIUIIUIIUIIU\" is derivable. You'll need several applications\nof rules 1 and 2.\n", "Try this both forward and backward. For your forward proof, call the hypotheses `h1`, `h2`, etc.\nYou can use underscores to replace variables in forward applications of rule 2, though not rule 1.\n", "`\"MIIUIIUIIUIIU\"` is derivable\n", "example : derivable \"MIIUIIUIIUIIU\" :=\nbegin\n  have h1 : derivable \"MIIU\", from rule1 \"MI\" der_MII,\n  have h2 : derivable \"MIIUIIU\", from rule2 _ h1,\n  from rule2 _ h2,\nend\n", "import game.rule_practice.level6 -- hide\n", "open letter -- hide\n", "## Level 7 : Rule 3\n", "Rules 1 and 2 are _lengthening_ rules. They show how to derive a longer string given the\nderivation of a shorter string.\n\nRules 3 and 4 are shortening rules.\n\nIn particular, rule 3 states xIIIy \u2192 xUy \n", "In the example below, we show `\"UMUIM\"` is derivable on the assumption `h`, that\n`\"UMIIIIM\"` is derivable. We specify `x` as `\"UM\"` in using rule 3. You don't need to specify the\nstring `y`. Lean automatically infers this value.\n", "example (h : derivable \"UMIIIIM\") : derivable \"UMUIM\" :=\nbegin\n  from rule3 \"UM\" h,\nend\n", "**Note** this example does not show `\"UMUIM\"` is derivable! Why not?\n", "Solve the next problem by adapting the proof of the example above.\n", "If `\"MMIIIIIM\"` is derivable, then so is `\"MMIUIM\"`.\n", "import game.rule_practice.level7 -- hide\n", "open letter -- hide\n", "## Level 8 : Rules 1, 2, and 3 practice\n", "Give a backward proof and a forward proof for the problem below.\n", "`\"MUIU\"` is derivable.\n", "example : derivable \"MUIU\" :=\nbegin\n  apply rule3 \"M\",\n  apply rule1,\n  apply rule2 \"II\",\n  apply der_MII,\nend\n", "import game.rule_practice.level8 -- hide\n", "open letter -- hide\n", "## Level 9 : Rule 4\n", "Rule 4 states xUUy \u2192 xy.\n\nAgain, we only need specify the `x` value. Lean automatically infers `y`.\n", "example (h : derivable \"IMUUI\") : derivable \"IMI\" :=\nbegin\n  from rule4 \"IM\" h,\nend\n", "Adapt the example to prove the result below. Then give a proof with a different value for `x`.\n", "If `\"UMUUUI\"` is derivable, then so is `\"UMUI\"`.\n", "import game.rule_practice.level9 -- hide\n", "open letter -- hide\n", "## Level 10 : All rules practice\n", "We've seen all rules now.\n\nThe next derivation is more challenging than the examples we've seen so far.\n\nThis is the last level of the first world. Before you move on to the next world, ask yourself, if\n`\"MU\"` can be derived.\n", "`\"MIIUII\"` is derivable\n", "Existence", "import game.rule_practice.level10 -- hide\n", "open letter list -- hide\n", "## Level 1 : The existential quatifier\n", "We've seen proofs that particular strings can be derived. In this world, we'll see how to \nprove that strings can be derived that satisfy certain properties.\n", "The example below claims there exists a letter a such that aII is derivable. The symbol \u2203 stands\nfor 'there exists'.\n\nThe notation `a :: \"II\"` means a letter represented by variable `a` followed by the string `\"II\"`.\n", "## Summary\n`use` is the first step in proving the existence of a term that satisfies a property.\n\n## Detail\nSuppose the target is to prove `\u2203 a, P(a)`, where `P` is some property. Suppose `m` is a term.\nThen\n```\nuse m\n```\nchanges the target to one of proving `P(m)`.\n\n## Variations\nIf the target is to prove `\u2203 a b, P a b` and `m`, `m` are terms, then\n```\nuse [m, n]\n```\nreplaces the target with one of proving `P m n`.\n", "The tactic `use M` fixes x to be `M` and changes the target to one of showing that\n`M :: \"II\"` is derivable. This is precisely the conclusion of `der_MII`.\n", "a :: y is the letter a followed by the string y.\n", "  use M,\n  from der_MII,", "There exists a letter a such that aII is derivable.\n", "There exists a letter a such that aIU is derivable.\n", "import game.existence.level1 -- hide\n", "open letter -- hide\n", "## Level 2 : Letters and strings\n", "The notation `x ++ y` means 'the string `x` followed by the string `y`'. Thus,\n`\"ho\" ++ \"use\"` is `\"house\"`.\n\nWe'll prove that there is a letter `a` and a string `y` such that `a :: y ++ y` is derivable by\ntaking `M` for `a` and `\"I\"` for `y`.\nNote that string constants are surrounded by double quotes.\n", "x ++ y is the string x followed by the string y.\n", "  use [M, \"I\"],  \n  from der_MII,", "There exists a letter a and a string y such that ayy is derivable.\n", "Give a solution to the following problem. Give another solution.\nHow many solutions are there?\n", "There exists a letter a and strings y, z such that ayzyz is derivable.\n", "import game.existence.level2 -- hide\n", "open letter list -- hide\n", "## Level 3 : Doing something with your existence\n", "The `use` tactic enables us to _prove_ existence. What if we're given the existence of some\nquantity. How do we use that information?\n", "Below `cases h with x hx` decomposes the `\u2203` statement\n```\nh : \u2203 (x : miustr), derivable (M :: (x ++ \"M\"))\n```\nIt replaces `h` with:\n1. a new string variable `z` and\n2. a new hypothesis `hz : derivable (M :: (z ++ \"M\"))`.\n\nWe then take `z` in place of `s` and `t` to prove the target.\n", "  cases h with z hz,\n  use [z, z],\n  apply rule2 (z ++ \"M\"),\n  from hz,", "Given that there exists a string `x` such that `M :: (x ++ \"M\")` is derivable,\nthere exist strings `s` and `t` such that `M :: s ++ \"M\" ++ (t ++ \"M\")` is derivable.\n", "## Summary\n`cases` is used to decompose a hypothesis.\n\n## Detail\nIf `h : p \u2228 q`, then `cases h with h1 h2` creates two new goals: (1) to prove the target under\nthe assumption `h1 : p` and (2) to prove the target under the assumption `h2 : q`.\n\nIf `h : \u2203 x, p x`, then `cases h with z hz` creates two new items in the context: (1) a\nvariable `z` and (2) the hypothesis `hz : p z`.\n", "Given there exists `x` such that `M :: (x ++ [I])` is derivable, we have that\nthere exists `y` such that `M :: (y ++ [I, U])` is derivable.\n", "import game.existence.level3 -- hide\n", "open letter list -- hide\n", "## Level 4 : Repeat\n", "The expression `repeat x n` represents `n` repetitions of the letter `x`.\nThus `repeat U 3` is the string `\"UUU\"`.\nUse this together with the `::` and `++` notation to make your argument clearer.\n", "Take `y` to be `\"\"`, the empty string and take `z` to be a suitable string of `I`s.\nYou can do this only with rules 2 and 3 (and the base case).\n", "Hint!", "repeat x n is n repetitions of the letter x.\n", "There exist strings y and z such that MyUUUz is derivable.\n", "example (y z : miustr) : \u2203 y z, derivable (M :: y ++ \"UUU\" ++ z) :=\nbegin\n  use [\"\", repeat I 7],\n  apply rule3 \"MUU\",\n  apply rule3 \"MU\",\n  apply rule3 \"M\",\n  apply rule2 (repeat I 8),\n  apply rule2 (repeat I 4),\n  apply rule2 (repeat I 2),\n  from der_MII,\nend\n", "import game.existence.level4 -- hide\n", "open letter list -- hide\n", "## Level 5 : A challenging existence example\n", "This is a trickier variant of the previous level. We require that the 'bookends' of the string\nare equal.\n\nIf you get stuck, move on to the next world and come back later. Remember, we're trying to\ndetermine if `\"MU\"` can be derived.\n", "Take `y` to be `\"I\"`. You will need all four rules for this problem.\n", "Hint!", "There exists a string y such that MyUUUy is derivable.\n", "example (y : miustr) : \u2203 y, derivable (M :: y ++ \"UUU\" ++ y) :=\nbegin\n  use \"I\",\n  have h1 : derivable (M :: repeat I 4), from rule2 _ der_MII,\n  have h2 : derivable (M :: repeat I 8), from rule2 _ h1,\n  have h3 : derivable (M :: repeat I 16), from rule2 _ h2,\n  have h4 : derivable (M :: repeat I 32), from rule2 _ h3,\n  have h5 : derivable (M :: repeat I 32 ++ \"U\"), from rule1 (M :: repeat I 31) h4,\n  have h6 : derivable (M :: repeat I 29 ++ \"UU\"), from rule3 (M :: repeat I 29) h5,\n  have h7 : derivable (M :: repeat I 26 ++ \"UUU\"), from rule3 (M :: repeat I 26) h6,\n  have h8 : derivable (M :: repeat I 23 ++ \"UUUU\"), from rule3 (M :: repeat I 23) h7,\n  have h9 : derivable (M :: repeat I 20 ++ \"UUUUU\"), from rule3 (M :: repeat I 20) h8,\n  have h10 : derivable (M :: repeat I 17 ++ repeat U 6), from rule3 (M :: repeat I 17) h9,\n  have h11 : derivable (M :: repeat I 14 ++ repeat U 7), from rule3 (M :: repeat I 14) h10,\n  have h12 : derivable (M :: repeat I 11 ++ repeat U 8), from rule3 (M :: repeat I 11) h11,\n  have h13 : derivable (M :: repeat I 11 ++ repeat U 6), from rule4 (M :: repeat I 11) h12,\n  have h14 : derivable (M :: repeat I 11 ++ repeat U 4), from rule4 (M :: repeat I 11) h13,\n  have h15 : derivable (M :: repeat I 11 ++ repeat U 2), from rule4 (M :: repeat I 11) h14,\n  have h16 : derivable (M :: repeat I 11), from rule4 (M :: repeat I 11) h15,\n  have h17 : derivable (\"MI\" ++ U :: repeat I 7), from rule3 \"MI\" h16,\n  have h18 : derivable (\"MI\" ++ \"UU\" ++ repeat I 4), from rule3 \"MIU\" h17,\n  from rule3 \"MIUU\" h18,\nend\n", "Numbers", "import game.existence.level5 -- hide\n", "## Level 1 : Reflexivity\n", "Despite the advances of the previous world, we've only been able to prove that strings _can_ be\nderived. How could we possibly show that a given string _cannot_ be derived?\n\nThe idea is to prove that every derivable string satisfies a certain easy-to-check property. If\na given string doesn't satisfy that property, then it isn't derivable!\n\nHere are some strings that we've derived so far. Can you spot a pattern?\n\n> MI, MIU, MIUIU, MUIU, MIUIUIUIU, MIIUIIUIIUIIU, MIIUU, MUUUIIIIIII.\n\nWe're searching for a numerical derivability criterion. To prepare you, we'll spend this world\nlooking at equations in Lean.\n", "## Proving equality with refl\n\nWhen two things are identical, the proof of their equality can be proved with the `refl` tactic\n\n", "  refl,", "\\\\(x + y = y + x\\\\)\n", "## Summary\n`refl` is used to show equality of identitcal terms.\n\n## Detail\n`refl` proves a target `x = y` if `x` is identical to `y`.\n\nIdentical here means either _exactly the same_ or equal by\ndefinition. For example `1 + 1` is, by definition of addition, equal to `2`.\nBut `x + y` is not (in general) defined to be equal to `y + x`.\n", "$y + xy = y + xy$\n", "import game.numbers.level1 -- hide\n", "## Level 2 : Rewriting\n", "Rewriting is used to make substitutions. Below, we show \\\\(10 + 2 x = 16\\\\) on the assumption `h`,\nthat \\\\(x = 3\\\\).\n\nTo do this, we rewrite the target with `h`, replacing `x` in the target with `3`.\n\n", "  rw h,\n  refl,", "If \\\\(x = 3\\\\), then \\\\(10 + 2 x = 16\\\\).\n", "## Summary\n`rw`, the rewrite tactic, is used for substitutions.\n\n## Detail\nIf `h` is an equation of the form `p = q`, `rw h` rewrites replaces `p` in the target with `q`.\n\nIf `k` is in the context, `rw h at k` performs the rewrite at `k` instead of at the target.\n\n`rw \u2190h` will rewrite backward: every occurrence of `q` is replaced with `p`. Type `\\l` to produce `\u2190`.\n\n`rw [h1, h2, h3]` rewrites with multiple hypotheses (you aren't limited to three)!\n", "For the next problem, you're given \\\\(y = 3\\\\) and you're asked to find \\\\(x\\\\) such that \n\\\\(20 + xy = 50.\\\\) You then need to prove equality.\n", "You'll need the `use`, `rw`, and `refl` tactics to prove the following result.\n\nYou can choose whether to do `use` or `rw` first. Try both approaches. Which is easier?\n", "Hint", "Given \\\\(y = 3\\\\), there exists an integer \\\\(x\\\\), such that  \\\\(20 + xy = 50.\\\\)\n", "import game.numbers.level2 tactic.ring -- hide\n", "## Level 3 : Proving equations with the ring tactic\n", "The `ring` tactic proves many polynomial identities.\n", "  ring,", "\\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2,\\\\) for every integer \\\\(x.\\\\)\n", "## Summary\n`ring` proves many polynomial identities.\n", "There exists an integer \\\\(a\\\\) such that  \\\\( (x-1)^3 = x ^ 3 - ax ^2 + a x - 1,\\\\) for\nevery integer \\\\(x.\\\\)\n", "import game.numbers.level3 tactic.ring -- hide\n", "## Level 4 : Making assumptions\n", "During a proof, the top-right pane shows the goal(s). A goal consists of two things:\n\n1. The set of hypotheses up to that point in the proof. This includes the variables introduced\nat the start of the proof, any other initial assumptions, and hypotheses introduced via `have`\nor other mechanisms.\n\n2. The target. This is what you're trying to prove. It's marked with that `\u22a2` symbol, which\nis read 'to prove' or 'to construct'.\n", "So far, all variables have been introduced into the context before the proof begins. We do this by\nlisting the variables to the left of the colon (`:`) symbol.\n\nSometimes, it's necessary to introduce variables and other hypotheses _during_ a proof.\n\nWe do this using the `assume` tactic.\n\nIn the example below, the symbol `\u2200` means 'for all' or 'for every'. It's typed `\\all`.\nThe symbol `\u2124` is typed `\\int` and stands for the integers.\n", "  assume x : \u2124, -- Assume `x` is an integer.\n  -- The target is `\u22a2 x ^ 2 - 2 * x + 1 = (x - 1) ^ 2`\n  ring,", "For every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n", "When using `assume`, the choice of variable name does not need to match the variable name\nin the 'for all' statement.\n\nThis is because (for example) `\u2200 (x y : \u2124), x + y = y + x` has _the same meaning_ as\n`\u2200 (s t : \u2124), s + t = t + s`. \n", "  assume s : \u2124, -- Assume `s` is an integer.\n  -- The target is `\u22a2 s ^ 2 - 2 * s + 1 = (s - 1) ^ 2`\n  ring,", "For every integer \\\\(x,\\\\) \\\\(x ^ 2 - 2 x + 1 = (x - 1) ^ 2.\\\\) \n", "The `assume` tactic can be used to introduce hypotheses too.\nThe statement\n```\nx = y + 5 \u2192 x ^ 2 = y ^ 2 + 10 * y + 25\n```\nis read 'if \\\\(x = y + 5,\\\\) then \\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\)'\n\nMore generally, `p \u2192 q` means 'if `p`, then `q`'.\n", "  assume x y : \u2124, -- Assume `x` and `y` are integers.\n  assume h : x = y + 5, -- Assume `h`, that `x = y + 5`.\n  rw h, -- Substitute `y + 5` for `x` in the target\n  ring, -- Prove `(y + 5) ^ 2 = y ^ 2 + 10 * y + 25`.", "For all integers \\\\(x\\\\) and \\\\(y,\\\\) if \\\\(x = y + 5,\\\\) then\n\\\\(x ^ 2 = y ^ 2 + 10 y + 25.\\\\) \n", "## Summary\n`assume` introduces a variable or hypothesis into the context.\n## Examples\n`assume x : \u2124` introduces the assumption that `x` is an integer.\n\n`assume h : x + 2 = 5` introduces the hypothesis `h` that `x + 2 = 5`.\n", "As you work on the problem below, note how the context changes with each assumption.\n\nIf you do the problem by introducing variables called `s` and `t`, try it again with\ndifferent variable names.\n", "Start with `assume s t : \u2124` or, if you're feeling adventurous, `assume x y : \u2124` \n", "Hint", "For all integers \\\\(s\\\\) and \\\\(t,\\\\), if \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 7,\\\\) then \\\\(5st = 350.\\\\)\n", "import game.numbers.level4 tactic.ring -- hide\n", "## Level 5 : Mixing 'there exists' and 'for all'\n", "The statement of the next problem starts with `\u2203`. Thus, the first thing you must do,\nbefore introducing assumptions, is to find  `a`.\n", "Start with the `use` tactic.\n", "Hint", "There exists an integer \\\\(a\\\\) such that for all integers \\\\(s\\\\) and \\\\(t,\\\\)\nif \\\\(s = t  + 3,\\\\) then if\n\\\\(t = 4,\\\\) then \\\\(2st = a.\\\\)\n", "import game.numbers.level5  -- hide\n", "## Level 6 : This or that\n", "Often, we are told that one thing _or_ another thing happens. If I know you like tea or you like\ncoffee, I definitely know you like a bitter-flavoured drink. In the mathematical world, a\nperson who likes tea or coffee might like both tea _and_ coffee.\n", "In this example, we prove that if \\\\(x = 1 \\lor x = 2,\\\\)  then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n The symbol `\u2228` (typed `\\or`) means 'or'. Thus, `h : x = 1 \u2228 x = 2` is the hypothesis that\n `x = 1` or `x = 2`.\n\nTo use this hypothesis, we consider the cases `x = 1` and `x = 2` separately.\nThe `cases` tactic splits `h` into two cases (which we've called `hl` and `hr`) and creates\ntwo new goals: (1) to prove the target under the assumption `hl : x = 1` and (2) to prove the\ntarget under the assumption `hr : x = 2`.\n\nIn the first case, for example, after `rw hl`, the target is to prove `1 ^ 2 - 3 * 1 + 2 = 0`.\n\nBraces are used here to separate the two goals.\n", "  cases h with hl hr, -- Text after a -- is a comment and is ignored.\n  { rw hl, refl, }, -- This is the case `x = 1`.\n  { rw hr, refl, }, -- This is the case `x = 2`.", "If \\\\(x = 1 \\lor x = 2,\\\\) then \\\\(x ^ 2 - 3 x + 2 = 0 .\\\\)\n", "There exists an integer \\\\(a\\\\) such that for all integers \\\\(x,\\\\) and \\\\(y,\\\\)\nif \\\\(x = 3 \u2228 y = -5,\\\\) then \\\\(x y + 3x - 3y = a.\\\\)\n", "import game.numbers.level6  -- hide\n", "## Level 7 : Proving 'or' statements\n", "We've seen the `cases` tactic used to analyse a given 'or' statement.\nBut how do we _prove_ an or statement?\n\nIf I want to prove you like tea or you like coffee, it suffices to prove that you like tea.\nThat is, it suffices to prove the 'left' part of the or statement.\n\nLikewise, it would also suffice for me to prove the right part of the statement.\n", "The `left` and `right` tactics are used to specify which side of the statement we want to prove.\nTyping `left` below changes the target from one of proving `x = 1 \u2228 x = 2` to one of proving\n`x = 1`.\n", "  left,\n  from h,\n", "If \\\\(x = 1,\\\\) then \\\\(x = 1 \\lor x = 2.\\\\)\n", "To help your reader, use the `show` tactic. This makes explicit what it is you're showing.\n", "example (x : \u2124) (h : x = 1) : x = 1 \u2228 x = 2 :=\nbegin\n  left,\n  show x = 1, from h,\nend\n", "`show` is used to specify the target.\n## Summary\nIf the target is `\u22a2 p`, type `show p` to relay this information to the reader.\n", "## Summary\n`left` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `left` changes the target to one of proving `p`.\n", "## Summary\n`right` can be used to prove an or statement.\n\n## Detail\nIf the target is to prove `p \u2228 q`, then `right` changes the target to one of proving `q`.\n", "You'll need one of `left` or `right`, followed by applications of `rw` and `refl`. \n", "Hint", "Given \\\\(x = 3,\\\\) we have \\\\(x + 3 = 7\\\\) or \\\\(4x = 12.\\\\)\n", "import game.numbers.level7 tactic.linarith -- hide\n", "## Level 8 : Solutions of equations\n", "Factorisation is a common technique for solving equations.\n\nIt depends on the fact that \\\\(xy = 0\\\\) if and only if \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\nThis fact is called `mul_eq_zero` in Lean. We can use it for rewriting.\n", "In the example below, we rewrite at `h` rather than at the target. That's because `h` matches\nthe left side of `mul_eq_zero`.\n", "  -- The `rw` line changes `h` to `x = 0 \u2228 y = 0`.\n  rw mul_eq_zero at h,\n  from h,\n", "If  \\\\(xy = 0\\\\) then \\\\(x = 0\\\\) or \\\\(y = 0.\\\\)\n", "A one-line proof of the above is `rwa mul_eq_zero at h`. The `rwa` performs a rewrite then tries\nto close the goal using the hypotheses. In this case, it succeeds with hypothesis `h`.\n", "x * y = 0 \u2194 x = 0 \u2228 y = 0\n", "## Summary \n`linarith` solves linear equations and inequalities.\n## Detail\nThe linarith tactic will automatically use any hypotheses in the context to help it close the goal.\n", "In the next example, we use the `linarith` tactic. This powerful tactic solves 'linear' equations and\ninequalities. By default, it will use any hypothesis in the context. Here, it solves the target `x = 7`\nusing the hypothesis `h : x - 7 = 0`.\n\nWe use the `ring` tactic to express equation `h` as a product. Note there is no `from` to match with `have`.\nThis is because `ring` is a tactic, not a proof term.\n", "  have h1 : x * y - 7 * y = y * (x - 7), ring,\n  -- After the `rw`, `h` becomes `y = 0 \u2228 x - 7 = 0`.\n  rw [h1, mul_eq_zero] at h,\n  cases h with hl hr,\n  { right,            -- The case `y = 0`.\n    show y = 0, from hl, }, \n  { left,             -- The case `x - 7 = 0`.\n    show x = 7,\n    linarith, },", "If \\\\(x y - 7y = 0,\\\\) then \\\\(x = 7\\\\) or \\\\(y = 0.\\\\) \n", "Adapt the proof of the example above to find \\\\(a\\\\) and \\\\(b\\\\) such that if  \\\\(x ^ 2 - 3 x + 2 = 0,\\\\)\nthen \\\\(x = a\\\\) or \\\\(x = b.\\\\)\n", "Given \\\\(x ^ 2 - 3 x + 2 = 0,\\\\) there exist integers \\\\(a\\\\) and \\\\(b\\\\) sucht that \\\\(x = a\\\\)\nor \\\\(x = b.\\\\)\n", "import game.numbers.level8 -- hide\n", "## Level 9 : Simp and nested cases\n", "The `simp` tactic is a turbo-charged version of `rw`. It will rewrite with the given\nlemmas and hypotheses multiple times until either it closes the goal or until\nit can make no further progress.\n\nIt also 'knows about' certain results and will use these automatically.\n\nIn the example below, we invoke `simp` with hypotheses `h1` and `h2`. But `simp` also\ncalls upon other resutlts including `zero_add` and `add_left_inj`. The benefit of `simp`\nis that you don't need to learn about these other results.\n", "  simp [h1, h2],", "If \\\\(a = b + c\\\\) and \\\\(b + c = 5,\\\\) then \\\\(0 + a + (b + c) ^ 2 = 5 + 5 ^ 2.\\\\)\n", "`simp` permits the use of `*` to refer to the set of all hypotheses. Thus the above proof could be\nwritten as follows.\n", "example (a b c : \u2124) (h1 : a = b + c) (h2 : b + c = 5) :\n0 + a + (b + c) ^ 2 = 5 + 5 ^ 2 :=\nbegin\n  simp *,\nend\n", "## Summary\n`simp` performs targetted rewriting of either the target or a hypothesis (using `simp at h`).\n## Detail\nIt applies a set of rewrites in different orders and possibly multiple times until it can make\nno more progress.\n\nCertain Lean results are marked as 'simp lemmas'. These are automatically applied by `simp`.\nYou can specify other results for `simp` to use by enclosing them in brackets:\n```\nsimp [h1, h1, h3],\n```\n## Variations\nThe symbol `*` can be included among the list of lemmas provided to `simp`. This asks\n`simp` to use _all_ the hypotheses in the context. For example,\n`simp [zero_add, *]` asks `simp` to use the `zero_add` result and all hypotheses in the context.\n\nLikewise `simp at *` asks Lean to simplify at the target at at all hypotheses in the context.\n", "In the proof below, we use nested cases. First we rewrite `h` and `k` with `mul_eq_zero` so\nthey become `h : x = 0 \u2228 y = 0` and `k : (x + y + 2 = 0) \u2228 (x + y + 3 = 0)`.\n\nThe outer `case` analyses the cases of `h`. Each inner case then analyses the cases of `k`.\n\nThe `at *` in our `simp` application means, 'simplify at the target and and every hypothesis'.\n", "  rw mul_eq_zero at h k,\n  cases h with h1 h2,\n  { cases k with k1 k2,\n    { simp * at *, },\n    { simp * at *, }, },\n  { cases k with k1 k2,\n    { simp * at *,  },\n    { simp * at *}, },", "If  \\\\(xy = 0\\\\) and \\\\((x + y + 2)(x + y + 3) = 0,\\\\) then\n\\\\((x + 2) (x + 3) (y + 2) (y + 3) = 0.\\\\)\n", "For the next problem, you'll need nested cases and a bit of ingenuity.\n", "You'll need to start by massaging the target into an appopriate form. The methods seen in earlier\nlevels will help you achieve this.\n", "Hint", "For integers \\\\(x\\\\) and \\\\(y\\\\), given \\\\(x = 2 \\lor y = 3,\\\\) given\n\\\\(x + y = 0 \\lor x - y = 0,\\\\) we have that \\\\(x ^ 2 - y ^ 2 + x + y\\\\) is \\\\(2 + y\\\\)\nor \\\\(x + 3.\\\\)\n", "Remainders", "import game.numbers.level8 -- hide\n", "open nat -- hide\n", "## Level 1 : Remainders\n", "In Lean, the remaininder on dividing `a` by `b` is denoted `a % b` and read '`a` mod `b`'.\n\nThus, `21 % 6 = 3`. Numerical results like this can be proved by reflexivity.\n", "  refl,", "The remainder on dividing 21 by 6 is 3.\n", "Remainders behave nicely with respect to addition and multiplication. \n\nWe know `21 % 6 = 3`. You can calulate `16 % 6 = 4`. So what is `(21 + 16) % 6`?\n\nWell `21 + 16 = 37` and `37 % 6 = 1`. Not coincidentally, `(21 % 6) + (16 % 6) = 3 + 4 = 7`\nand `7 % 6 = 1`.\n\nIn general, `(a + b) % m = ((a % m) + (b % m)) % m`.\n\nThis result is called `add_mod a b m`.\n", "(a + b) % m = ((a % m) + (b % m)) % m\n", "We use `rw add_mod x y` in the example below to specify where the rewriting takes place.\nIf we wrote `rw add_mod`, `rw add_mod x`, `rw add_mod x x`, or `rw add_mod x x 10`,\nthe expression `(x + x) % 10` would be rewritten.\n", "  rw add_mod x y,", "\\\\(x + y \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\)\nof the sum of  \\\\(x \\mod{10}\\\\) and \\\\(y \\mod{10}\\\\).\n", "Applying the remainder operator twice has the same effect as applying it once.\nThat is, `(a % m) % m = a % m`. This result is called `mod_mod`.\n", "(a % m) % m = a % m\n", "  rw [mod_mod, mod_mod, mod_mod],", "The four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n", "It's slightly irritating to specify `mod_mod` multiple times. An alternative is to use the\n`simp` tactic. This applies its arguments as many times as necessary and in varying orders until\nit can make no more progress.\n", "  simp [mod_mod],", "The four-fold remainder on division of \\\\(x\\\\) by \\\\(10\\\\) is the same as\n\\\\(x \\mod{10}.\\\\)\n", "In fact, the above proof could be written `simp,`. This is because some results (including\n`mod_mod`) are marked as 'simp lemmas'. This means `simp` will automatically use them for rewriting,\nunless instructed otherwise.\n", "Try proving the following result (1) using a sequence of `rw`s and (2) via `simp`.\n\nNote that Lean interprets `a + b + c` as `(a + b) + c`.\n", "\\\\(x + y + z \\mod{10}\\\\) is the remainder on division by \\\\(10\\\\) \nof the sums of \\\\(x \\mod{10}\\\\), \\\\(y \\mod{10}\\\\), and \\\\(z \\mod{10}.\\\\)\n", "import game.remainders.level1 -- hide\n", "open nat -- hide\n", "## Level 2 : Dealing with remainders by cases\n", "Remainders behave nicely with respect to multiplication.\n`mul_mod a b m` is the result that\n```\n(a * b) % m = ((a % m) * (b % m)) % m\n```\n", "(a * b) % m = ((a % m) * (b % m)) % m\n", "Using this, we prove that \\\\(a ^ 2\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n\n", "  cases h with h1 h2,\n  { simp [mul_mod, h1], },\n  { -- `simpa` does a `simp` then tries to close \n    -- the goal with an assumption or reflexivity.\n    simpa [mul_mod, h2], }, ", "\\\\(a \\times a\\\\) leaves remainder \\\\(1\\\\) on division by \\\\(4\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(1\\\\) or \\\\(3\\\\) on division by \\\\(4.\\\\)\n", "There exists a natural number \\\\(n\\\\) such that for every natural number \\\\(a,\\\\) if\n\\\\(a\\\\) leaves remainder \\\\(3\\\\) or \\\\(2\\\\) on division by \\\\(5\\\\), then \\\\(a \u00d7 a\\\\) leaves\nremainder \\\\(n\\\\) on division by \\\\(5.\\\\)\n", "import game.remainders.level2 -- hide\n", "open nat -- hide\n", "## Level 3 : A useful result\n", "The following result will be useful in our study of the MIU system.\n", "You'll need to do a proof by nested cases. The `simp` tactic or its\n`simpa` variant will come in helpful, especially with `mul_mod`.\n", "Hint", "Let \\\\(a\\\\) and \\\\(b\\\\) be natural numbers.\nGiven that \\\\(a \\mod 3\\\\) is \\\\(1\\\\) or \\\\(2\\\\),\ngiven that \\\\(b \\mod 3\\\\) is \\\\(a \\mod 3\\\\) or \\\\(2a \\mod 3,\\\\)\nwe have that \\\\(b \\mod 3\\\\) is \\\\(1\\\\) or \\\\(2\\\\).\n", "Lists", "import game.numbers.level8 -- hide\n", "open letter -- hide\n", "## Level 1 : List notation\n", "Under the hood, derivability in the MIU sytem is concerned not with\nstrings, but with lists of letters.\n\nFor example, the string `\"MIU\"` is interpreted as a list `[M, I, U]` of letters.\n", "  have h1 : derivable [M, I, I], from rule2 [I] der_MI,\n  have h2 : derivable [M, I, I, I, I], from rule2 [I, I] h1,\n  from rule1 [M, I, I, I] h2,", "The list `[M, I, I, I, I, U]` is derivable.\n", "**Caution**: the `use` tactic needs to be treated carefully when dealing with lists.\nIf you typed `use [I]` below, Lean would assume you were trying to use the letter `I` rather than\nthe list `[I]`.\n", "  use [[I]],\n  apply rule3 [M],\n  apply rule2 [I, I],\n  apply rule2 [I],\n  from der_MI,", "There is a list `a` such that `[M, U] ++ a` (i.e. `a` appended to `[M, U]`) is derivable.\n", "Note that the empty (or nil) list is denoted `[]`.\n\nThe aim for the remainder of this world is to prove a couple of necessary conditions for a\nlist to be derivable in the MIU system. The conditions will concern the location(s) of the\nletter `M` in any derivable list.\n\nThe following problem has a one-line proof.\n", "There is a list `ys` such that `[M, I] = M :: ys`.\nThat is, the base derivable string in the MIU system starts with a `M`.\n", "import game.lists.level1 -- hide\n", "open letter -- hide\n", "## Level 2 : Rule 2 and `M`\n", "In the previous level, we showed that `[M, I]`, the base element of the MIU system,\nstarts with an `M`.\n\nMore precisely, when we say a list `ys` starts with an `M`, we mean that there exists a list `xs`\nsuch that `ys = M :: xs`.\n\n\nIn this level, we'll skip over rule 1 and show that if a string (i.e. list) in MIU is constructed\nvia rule 2, then it must also start with an `M`.\n\nRecall rule 2 states that if Mz is derivable, then so is Mzz. In our list language, a list\nderived by rule 2 must thus have the form `(M :: zs) ++ zs`, for some list `zs`.\n\nYour task is to prove that if a list has the form `(M :: zs) ++ zs`, then it starts with an `M`.\nThat is, there exists a list `xs` such that `(M :: zs) ++ zs = M :: xs`.\n\n**Note** the expression `(M :: zs) ++ zs` is not _syntactically_ the same as `M :: (zs ++ zs)`.\nHowever, the expressions are equal. This equality is known to the `simp` tactic.\n", "Any list constructed by rule 2 must start with the letter `M`.\n", "import game.lists.level2 -- hide\n", "open letter list -- hide\n", "## Level 3 : What is a list? Rule 1\n", "Just as derivability has a a base case and rules of production, so the _construction_ of a\nlist has two rules.\n\nA list is either:\n\n1. The nil list, `nil` (denoted `[]`) or\n2. `cons x xs` (denoted `x :: xs`) where `x` is a letter and `xs` is a list.\n\nA definition with a base case (or cases) and constructors that refer to already-constructed terms\nis called an _inductive defintion_.\n", "  refl,", "Constructing a list with `::` and `[]`.\n", "  refl,", "Constructing a list with `cons` and `nil`.\n", "For the next problem, we continue looking at derivable strings (i.e. lists) in MIU.\nAny list constructed by rule 1 must take the form `zs ++ [I, U]` where\n`zs ++ [I]` is derivable.\n\nLet's _assume_ that the list `zs ++ [I]` starts with the letter `M`.\nThat is, assume `\u2203 (ys : list letter), zs + [I] = M :: ys`.\n\nWe'll prove that the list `zs ++ [I, U]` also starts with the letter `M`.\n", "We record here a lemma that will be useful for this problem and other subsequent problems.\n", "\u2200 (xs : list letter), zs ++ [I, U] = (zs ++ [I]) ++ [U]\n", "lemma append_IU_eq_append_I_append_U (zs : list letter) :\nzs ++ [I, U] = (zs ++ [I]) ++ [U] :=\nbegin\n  simp,\nend\n", "Recall that an `\u2203` statement can be decomposed via the `cases` tactic. Start your proof with\n`cases h with ys hys`.\n", "Hint for dealing with hypothesis `h`", "If you followed the previous hint, you'll be left with\n```\nhys : zs ++ [I] = M :: ys\n```\nBut your target will has the form\n```\n\u22a2 \u2203 ws, zs ++ [I, U] = M :: ws\n```\nThe left side of this expression doesn't exactly match the left side of `hys`.\nHowever, you can use `append_IU_eq_append_I_append_U` either via `rw` or `simp`.\n", "Hint for using the decomposed hypothesis `h`", "If a list is constructed by rule 1 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n", "import game.lists.level3 -- hide\n", "open letter list -- hide\n", "## Level 4 : Functions on lists and proof by cases\n", "As we saw in a previous level, lists have an inductive definition. A list is either `[]` or `x :: xs`\nfor a letter `x` and a list `xs`.\n\nThus, to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n", "For the most simple kind of function, the value of `f(xs)` is not used in constructing `f(x :: xs)`.\n\nWe define a function `noggin` such that `noggin [] = U` and `noggin (x :: xs) = x`.\nThere's nothing special about `U` here, but we have to give _some_ value to `noggin []`. I've\njust chosen `U`.\n", "def noggin : list letter \u2192 letter\n| []          := U\n| (x :: xs)   := x\n/- We can prove some concrete `noggin` results through reflexivity. -/\n", "  refl,", "The `noggin` of `[M, I, U]` is `M`.\n", "Of course, `noggin ys` can be thought of as 'the first letter' of `ys`. This only makes sense if\n`ys` is not the nil list.\n", "Earlier, we said that for a list `ys` to start with `M` means that there exists `xs` such that\n`ys = M :: xs`. It would be nice for this notion to imply that `noggin ys = M`.\n\nIndeed, we can prove such a result. We decompose `ys` into two possibilities.\n\n1. `ys` is the nil list, `[]` or\n2. `ys` is `p :: ps`, for some letter `p` and some list `ps`.\n\nWe're assuming `h : \u2203 xs, ys = M :: xs`.\n\nIn case 1., `h` becomes `h : \u2203 xs, [] = M :: xs`. This is clearly nonsense. We close this\ngoal using `simp * at *`.\n\nIn case 2., `h` becomes `h : \u2203 xs, (p :: ps) = M :: xs`. We start by decomposing `h` by cases\ninto the list `zs` and the hypothesis `hzs : (p :: ps) = M :: zs`. The goal is closed via\n`simp [*, noggin] at *`.\n", "In Lean, the `cases` tactic performs this decomposition of `ys`. In principle, it's exactly the\nsame as decomposing an or statement `k : p \u2228 q` into a left part and right part.\n\nThe difference is that we need to label the variables that arise in the `cons` case. For example,\n`cases ys with p ps` means that the `cons` case should treat `ys` as `p :: ps`.\n\nWe use the `show` tactic below to help the reader understand what's happening in the `cons` case.\nIt isn't necessary for Lean.\n", "  cases ys with p ps, -- In the `cons` case, `ys = p :: ps`.\n  { simp * at *, },             -- The `nil` case\n  { show noggin (p :: ps) = M,  -- The `cons` case.\n    cases h with zs hzs, \n    simp [*, noggin] at *, },", "Given a list `ys`, if `\u2203 xs, ys = M :: xs`, then `noggin ys = M`.\n", "Lean offers an alternative format wherein each case is labelled with the constructor and any\nnecessary variables. We do this with the `case` tactic, as exemplified below.\n\n", "example {ys : list letter}\n(h : \u2203 (xs : list letter), ys = M :: xs) : noggin ys = M :=\nbegin\n  cases ys,\n  case nil :          -- The `nil` case.\n  { simp * at *, },\n  case cons : p ps    -- The `cons` case.\n  { show noggin (p :: ps) = M,\n    cases h with zs hzs,\n    simp [*, noggin] at *, },\nend\n", "Using the `cases` tactic, prove that if a list is constructed via rule 3 from a list that\nstarts with the letter `M`, then the constructed list also starts with the letter `M`.\n", "If a list is constructed by rule 3 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n", "import game.lists.level4 -- hide\n", "open letter list -- hide\n", "## Level 5 : Rule 4\n", "Your task in this level is to prove that f is a list is constructed by rule 4 from a list that starts\nwith the letter `M`, then the constructed list also starts with the letter `M`.\n", "If a list is constructed by rule 4 from a list that starts with the letter `M`, then the \nconstructed list also starts with the letter `M`.\n", "import game.lists.level5 -- hide\n", "open letter list -- hide\n", "## Level 6 : Recursive functions on lists\n", "Previously, we saw that to define a function `f` on lists is to define:\n\n1. `f([])` and\n2. how to construct `f(x :: xs)` given `f(xs)`.\n", "In our example `noggin`, the definition of `noggin (x :: xs)` did not depend on `noggin xs`. Things\nare more interesting when there is such a dependence.\n\n\nThe function `interleave` is defined so that if `y`\nis a letter, then\n\n1. `interleave y [] = []` and\n2. `interleave y (x :: xs) = x :: (y :: (interleave y xs))`, for any letter `x` and any list `xs`.\n\nInformally, its action is to pull out the first letter of a list, add in the given letter `y`,\nthen repeat the process. Thus the letter `y` is interleaved with the letters of the original list.\n", "def interleave : letter \u2192 list letter \u2192 list letter\n| y []        := []\n| y (x :: xs) := x :: (y :: (interleave y xs))\n", "  -- The extra `[ ... ]` are needed due to the use of list notation.\n  use [ [U, M, I, M, I, M]  ],\n  refl,", "We find `a`, the result of interleaving `M` with `[U, I, I]`.\n", "The problem for this level is for you to understand the mysterious function `mystery`.\n", "def mystery : list letter \u2192 \u2115\n| []        := 0\n| (x :: xs) := (mystery xs) + 1\n", "Find the value of the natural number `a` below.\n", "There is a natural number `a` such that `mystery [U, I, M] = a`.\n", "import game.lists.level6 -- hide\n", "open letter list -- hide\n", "## Level 7 : Structural induction on lists\n", "In a previous level, we show that if a list `ys` has the property that there exists a list `xs`\nfor which `ys = M :: xs`, then `noggin ys = M`.\n\nWe proved this by decomposing `ys` into cases, via the `cases` tactic. This sufficed because the\ndefinition of `noggin` is not truly recursive. That is, `noggin (x :: xs)` does not explicitly\ndepend on `noggin xs`.\n\nIn general, proving results that involve a recursive function requires a more sophisticated\nprinciple called _structural induction_ (or sometimes just _induction_). This is a generalisation\nof the induction principle for natural numbers that you may have seen at school.\n\nStructural induction on lists involves proving two things.\n\n1. Prove the result holds for the nil list.\n2. _Assuming_ that the result hold for a given list `xs`, prove that for every letter `x`, the\nresult holds for the list `x :: xs`.\n\nIn a proof by induction, 1. is called the base case and 2. is called the inductive step.\n", "As a first example, we prove `mystery(ys ++ [x]) = mystery(ys) + 1`, for every letter `x` and\nevery list `ys`.\n\nWe do this by induction on `ys`.\n\n1. The base case is when `ys` is the nil list. We must prove `mystery (nil ++ [x]) = mystery nil + 1`.\n2. For the inductive step, `ys` is `z :: zs` for a letter `z` and a list `zs`.\nWe assume `ih : mystery (zs ++ [x]) = mystery zs + `. This is called the induction hypothesis.\nWe must prove `mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1.`\n\nI've used the `show` tactic in the proof below to indicate the targets of the base case and the\ninductive step. You don't need to do this, but it is recommended for clarity.\n", "  induction ys, -- Proof by induction, analysing the variable ys.\n  case nil :            -- The base case.\n  { show mystery (nil ++ [x]) = mystery nil + 1,    \n    simp [mystery] },               \n  case cons : z zs ih   -- The inductive step.\n  { show mystery (z :: zs ++ [x]) = mystery (z :: zs) + 1,\n    simp [mystery, ih], }, ", "For every letter `x` and every list `ys`, we have `mystery(ys ++ [x]) = mystery(ys) + 1`.\n", "Try induction on `xs`.\n", "Hint", "For all lists `xs` and `ys`, we have `mystery(xs ++ ys) = mystery xs + mystery ys`\n", "import game.lists.level7 -- hide\n", "open letter list -- hide\n", "## Level 8 : Inductively defined propositions\n", "Just as data (such as lists) can be defined inductively, so propositions can be defined inductively.\n\nWe've been working with an inductively defined proposition throughout this game: the proposition\n`derivable` has a base case, that `[M, I]` is derivable, and four recursive constructors, the\nfour production rules.\n\nThe cases are `derivable_MI`, `r1`, `r2`, `r3`, `r4`. These correspond to the results we've called\n`der_MI`, `rule1`, `rule2`, `rule3`, and `rule4`.\n", "By induction, and using the results `cons_M_MI`, `cons_M_r1`, etc., we'll prove that every\nderivable list starts with an `M`.\n", "Every derivable list starts with an `M`.\n", "lemma cons_M_of_derivable {xs : list letter} (h : derivable xs) :\n\u2203 ys, xs = M :: ys :=\nbegin\n  induction h,\n  case derivable_MI         -- The base case.\n  { from cons_M_MI, },\n  case r1 : zs h ih         -- The first inductive case.\n  { apply cons_M_r1 ih, },\n  case r2 : zs h ih         -- The second inductive case.\n  { apply cons_M_r2, },\n  case r3 : zs ws h ih      -- The third inductive case.\n  { apply cons_M_r3 ih, },\n  case r4 : zs ws h ih      -- The fourth inductive case.\n  { apply cons_M_r4 ih, },\nend\n", "Using this, we'll prove that `[U, I]` is _not_ derivable. This is our first negative result.begin\nThe symbol `\u00ac` (typed `\\not`) means 'not'.\n\nTo prove a not statement, we _assume_ the statement is true then try to derive a contradiction.\n\nUsing the result `cons_M_of_derivable`, we deduce that there is a list `ys` such that\n`[U, I] = M :: ys`. Call this list `zs` and the hypothesis `hzs : [U, I] = M :: zs`.\nUsing this, we get a contradiction (via `simp * at *`).\n", "  -- We assume `derivable [U, I]`. It remains to prove `false`.\n  assume h : derivable [U, I],\n  have h2 : \u2203 ys, [U, I] = M :: ys, from cons_M_of_derivable h,\n  cases h2 with zs hzs,\n  simp * at *,", "The list `[U, I]` is not derivable.\n", "### A shortcut\nYou'll note in the proof above that the hypothesis `h2` is introduced via `have` then immediately\ndecomposed via `cases`. The two lines can be combined and the hypothesis `h2` omitted.\n", "example : \u00ac (derivable [U, I]) :=\nbegin\n  assume h : derivable [U, I],\n  cases cons_M_of_derivable h with zs hzs,\n  simp * at *,\nend\n", "No list that begins with an `I` is derivable.\n", "import game.lists.level8 -- hide\n", "open letter list -- hide\n", "## Level 9 : Noggins and tails\n", "We've proved that every derivable list must start with `M`. By now, you've surely noticed that\nno derivable list has an `M` in its 'tail'. By `tail`, I mean the function defined by:\n1. `tail [] = []`,\n2. `tail (x :: xs) = xs`.\n", "You'll prove this result by induction. In addition to one of the results already proved in this\nworld, you'll need the following lemma _and_ you'll need `tail_append_singleton_of_ne_nil`.\n\n`not_in_tail_of_not_in_self` states that if `M` is not in `ws`, then `M` is not in the tail of `ws`.\n\n`tail_append_singleton_of_ne_nil` states that if `xs \u2260 nil` (i.e. `xs` is not `nil`), then\nthe tail of `xs ++ [x]` is `(tail xs) ++ [x]`.\n\n\nNote that `\u2260` is typed `\\ne`.\n", "\u2200 ws, M \u2209 ws \u2192 M \u2209 tail ws\n", "lemma not_in_tail_of_not_in_self (ws : list letter)\n(h : M \u2209 ws) : M \u2209 tail ws :=\nbegin\n  cases ws with p ps,\n  { simp * at *, },\n  { simp [*, not_or_distrib] at *, },\nend\n", "\u2200 xs x, xs \u2260 nil \u2192 tail (xs ++ [x]) = (tail xs) ++ [x]\n", "You may wish to use the following as a template for your proof.\n\n```\nexample (xs : list letter)\n(h : derivable (xs)) : M \u2209 tail xs :=\nbegin\n  induction h,\n  case derivable_MI\n  { sorry, },\n  case r1 : zs h ih\n  { sorry, },\n  case r2 : zs h ih  \n  { sorry, },\n  case r3 : zs ws h ih  \n  { sorry, },\n  case r4 : zs ws h ih\n  { sorry, },\nend\n```\n", "Ok, now it's your turn!\n", "`M` does not appear in the tail of a derivable list.\n", "Counting", "import game.lists.level9 game.remainders.level3 -- hide\n", "open letter list nat -- hide\n", "## Level 1 : Counting\n", "To progress to this world, you should have finished its parents, the Lists and Remainders worlds.\n\nThe aim of this world is to develop a necessary numerical condition for derivability. Using this,\nwe'll resolve the question of the derivability of `\"MU\"`.\n", "The criterion concerns the number of occurrences of a certain letter in a derivable string.\nThe Lean function `count` computes this quantity. Its definition is (roughly) as follows.\n", "namespace hidden -- hide\n", "def count : letter \u2192 list letter \u2192 \u2115\n| y []          :=  0\n| y (x :: xs)   :=  if y = x\n                    then (count y xs) + 1\n                    else (count y xs)\n", "end hidden -- hide\n", "Informally, `count y xs` is the number of occurrences of letter `y` in list `xs`.\nAs with `mystery`, concrete results about `count` can be proved by reflexivity.\n", "  refl,", "The list `[M, U, M]` contains one occurrence of the letter `U`.\n", "### Proving and statements\nWe've seen how to prove an 'or' statement. To prove `p \u2228 q`, we use either `left` and then prove `p`\nor we use `right` and then prove `q`.\n\nThe symbol `\u2227` stands for `\\and`. To prove `p \u2227 q` we use the `split` tactic. This creates two new\ngoals.\n\n1. To prove `p`.\n2. To prove `q`.\n", "## Summary\n`split` is used to prove and statements.\n## Detail\nIf the target is to prove `p \u2227 q`, the `split` tactic creates two new goals.\n1. To prove `p`.\n2. To prove `q`.\n", "  split,  -- create two new goals.\n  { show x = 0,     -- The first goal is to prove `x = 0`.\n    simp * at * }, \n  { show y = 0,     -- The second goal is to prove `y = 0`.\n    simp * at *, } ", "If \\\\(x\\\\) and \\\\(y\\\\) are natural numbers (i.e. non-negative integers) such that \\\\(x + y = 0\\\\),\nthen \\\\(x = 0\\\\) and \\\\(y = 0.\\\\)\n", "Using the two big results from the Lists world, we can prove that `count M xs = 1`, for every\nderivable list `xs`.\n", "  -- After `cases`, we get `hxs : ys = M :: xs`.\n  cases (cons_M_of_derivable h) with xs hxs, \n  rw hxs, -- The target becomes is `\u22a2 count M (M :: xs) = 1`\n  have h2 : M \u2209 tail ys, from M_notin_tail_of_derivable_self h,\n  simp * at *,", "If `xs` is derivable, then `count M xs = 1`.\n", "Your task is to find a list `xs` such that `xs` has exactly three occurrences of `U`\n_and_ such that `xs` is derivable.\n", "Start with `use` to introduce the string (if you're using a list, remember to use double brackets).\n\nThen use `split` to decompose the goal into two new goals.\n\nRemeber that the `repeat` function can help with expressing repeated letters.\n", "Hint", "There exists a list `xs` such that `count U xs = 3` and `xs` is derivable.\n", "import game.counting.level1-- hide\n", "open letter list nat -- hide\n", "## Level 2 : Counting occurrences of `I`\n", "In the last level, we saw that every derivable list has exactly one occurrence of `M`.\n\nIf you did the problem from that level, you should be able to convince yourself (though the Lean\nproof takes some work), that for every natural number `n`, there exists a derivable list `xs`\nwith exactly `n` occurrences of `U`.\n\nThe real question concerns the number of occurrences of `I`. If you haven't examined this yet,\ngo back and look at some examples. What do you notice?\n", "The only count values we've seen so far for `I`s in derivable lists are: 1, 2, 4, 5, 7, 8, 10, 11, ...\n\nThe pattern here is that we have every possibility *except* multiples of 3.\n\nAnother way to state this conjecture is that if `xs` is derivable, then `count I xs` should leave\nremainder 1 or 2 on division by 3.\n\nAs in the Lists world, we'll prove this by induction on the hypothesis that `xs` is derivable.\n", "To make our proofs concise, we introduce a predicate that represents the notion in which we\nare interested.\n", "def cieq (xs : list letter) :=\n(count I xs % 3) = 1 \u2228 (count I xs % 3) = 2\n", "Given this definition, our aim is to prove `cieq xs` holds for every derivable list `xs`.\n\nIn this level, we start with the base case.\n", "If you ever get confused regarding how a definition applies, you can type `unfold f` to\nexpand out the definition. In this case, you can (though it isn't necessary) type\n`unfold cieq` as the first line of your proof.\n\nIn future levels, `unfold cieq at *` can be used to unfold `cieq` everywhere.\n", "## Summary\n`unfold` expands a given definition.\n## Details\nIf the target contains (say) the function `cieq`, then `unfold cieq` will replace `cieq`\nwith its definition.\n\nType `unfold cieq at h` to unfold `cieq` at hypothesis `h`.\n\nType `unfold cieq at *` to unfold `cieq` at the target and at every hypothesis.\n\n", "`cieq ([M, I])` holds.\n", "import game.counting.level2 -- hide\n", "open letter list nat -- hide\n", "## Level 3 : Counting occurrences of `I`, rule 1\n", "You know the drill. We're moving on to prove the result for rule 1.\nThat is is, we show that if a list is constructed by rule 1 from a list that satisfies `cieq`,\nthen so does the constructed list.\n", "Start by applying the big result we proved in Remainders world.\n", "Hint", "If `cieq (xs ++ [I])` holds, then so does `cieq (xs ++ [I, U])`.\n", "import game.counting.level3 -- hide\n", "open letter list nat -- hide\n", "## Level 4 : Counting occurrences of `I`, rule 2\n", "It may help to use the result `two_mul` which states\n`\u2200 x, 2 * x = x + x`.\n", "Hint", "If `cieq (xs ++ [I])` holds, then so does `cieq (xs ++ [I, U])`.\n", "import game.counting.level4 -- hide\n", "open letter list nat -- hide\n", "## Level 5 : Counting occurrences of `I`, rule 3\n", "For this problem, `simp` will cause issues as it will perform simplifications that\ndon't help. You can either stick with `rw` or use `simp only`. This latter tactic only uses\nthe specified hypotheses or lemmas for rewriting.\n", "For this level, you'll need to rewrite with the theorems `count_append`,\n`add_right_comm`, and `add_mod_right`. These are described in the sidebar.\n\nYou'll find the two results `count_III` and `count_I_cons_U` below to be helpful.\n", "", "lemma count_III : count I [I, I, I] = 3 :=\nbegin\n  refl,\nend\n", "", "lemma count_I_cons_U (ys : list letter) :\ncount I (U :: ys) = count I ys :=\nbegin\n  simp,\nend\n", "(a + b) + c = (a + c) + b\n", "(x + z) % z = x % z\n", "count a (xs ++ ys) = count a xs + count a ys\n", "If `cieq (xs ++ [I,I,I] ++ ys)` holds, then so does `cieq (xs ++ U :: ys)`.\n", "import game.counting.level5 -- hide\n", "open letter list nat -- hide\n", "## Level 6 : Counting occurrences of `I`, rule 4\n", "Some of the comments from the previous level, regarding rule 3, also apply to this level.\n", "If you need a result similar to `count_III` from the previous level, remember that you can\nintroduce hypotheses into the context using the `have` tactic.\n", "Hint", "If `cieq (xs ++ [U, U] ++ ys)` holds, then so does `cieq (xs ++ ys)`.\n", "import game.counting.level6 -- hide\n", "open letter list nat -- hide\n", "## Level 7 : Counting occurrences of `I`, putting it together\n", "By induction, we'll bring together the small results proved in this world to give a\nbig result!\n\nNamely, we'll show that if `xs` is derviable, then `cieq xs` holds. That is,\n`count I xs % 3` is 1 or 2.\n", "If you like, you can use the text below as a template for your proof.\n\n```\nexample {xs : list letter}\n(h : derivable xs) : cieq xs :=\nbegin\n  induction h,\n  case derivable_MI\n  { sorry, },\n  case r1 : zs h ih\n  { sorry, },\n  case r2 : zs h ih  \n  { sorry, },\n  case r3 : zs ws h ih  \n  { sorry, },\n  case r4 : zs ws h ih\n  { sorry, },\nend\n```\n", "If `xs` is derivable, then `cieq xs` holds.\n", "import game.counting.level7 -- hide\n", "open letter list nat -- hide\n", "## Level 8 : The `\"MU\"` puzzle\n", "Finally, we can answer the `\"MU\"` puzzle. That is, we can determine\nwhether `\"MU\"` is derivable.\n", "You may need to use the `unfold` tactic to expand the definition of `cieq`.\n", "Hint", "`\"MU\"` is not derivable.\n"]]}